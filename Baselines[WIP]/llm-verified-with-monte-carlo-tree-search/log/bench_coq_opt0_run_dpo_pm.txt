

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 10 --language Coq --problem_name problem_opt0 --seed 42 --base_model_name ./my_dpo_model400s 


[2024-01-26 22:49:02,738] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.
File "./ex.v", line 4, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.
File "./ex.v", line 5, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.
File "./ex.v", line 5, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Set :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 18, characters 24-35:
Error:
In environment
eval : Expr -> (string -> nat) -> nat
e : Expr
env : string -> nat
e1 : Expr
e2 : Expr
The term "eval e1 env" has type "nat" while it is expected to have type "Z".


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.
File "./ex.v", line 18, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition evaluate (e : Expr) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.
File "./ex.v", line 18, characters 26-34:
Error: The reference evaluate was not found in the current environment.


SCORE
-1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.
SCORE
1.0
['ZArith_dec.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.
File "./ex.v", line 18, characters 24-39:
Error:
In environment
evaluate : expr -> (string -> nat) -> nat
e : expr
env : string -> nat
e1 : expr
e2 : expr
The term "evaluate e1 env" has type "nat" while it is expected to have type
 "Z".


SCORE
-1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 18, characters 24-35:
Error:
In environment
eval : expr -> (string -> nat) -> nat
e : expr
env : string -> nat
e1 : expr
e2 : expr
The term "eval e1 env" has type "nat" while it is expected to have type "Z".


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n| Const : nat -> expr\n| Var : string -> expr\n| Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Definition value (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition value (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Definition value (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (value e1 env) (value e2 env)
  end.
File "./ex.v", line 18, characters 24-36:
Error: Illegal application (Non-functional construction): 
The expression "value e1" of type "option expr"
cannot be applied to the term
 "env" : "string -> nat"


SCORE
-1.0
['add (value e1 env) (value e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArith_dec.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.
File "./ex.v", line 18, characters 24-39:
Error:
In environment
evaluate : expr -> (string -> nat) -> nat
e : expr
env : string -> nat
e1 : expr
e2 : expr
The term "evaluate e1 env" has type "nat" while it is expected to have type
 "Z".


SCORE
-1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import StringNotations.
File "./ex.v", line 7, characters 7-22:
Error: Cannot find module StringNotations


SCORE
-1.0
['\nImport StringNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 16, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2].
  - reflexivity.
File "./ex.v", line 30, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2].
  - simpl.
File "./ex.v", line 30, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2].\n  - simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 30, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
File "./ex.v", line 30, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2]; simpl.']
['\n  induction e as [|n|x|e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
['add (eval e1 env) (eval e2 env)\n  end.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.
SCORE
1.0
["\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, _ => e2\n    | _, Const 0 => e1\n    | e1', e2' => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n\nTheorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 34, characters 17-37:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x e1 e2 IHe1 IHe2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Const *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Var *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Add *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 42, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - (* Add *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - (* Add *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - (* Var *)\n    simpl.']
[' reflexivity.']
['\n  - (* Add *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.
File "./ex.v", line 4, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.ZArithNotations.
File "./ex.v", line 6, characters 7-29:
Error: Cannot find module ZArith.ZArithNotations


SCORE
-1.0
['ZArithNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.BinNums.
File "./ex.v", line 7, characters 7-21:
Error: Cannot find module ZArith.BinNums


SCORE
-1.0
['BinNums.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n| Const : nat -> Expr\n| Var : string -> Expr\n| Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 18, characters 24-35:
Error:
In environment
eval : Expr -> (string -> nat) -> nat
e : Expr
env : string -> nat
e1 : Expr
e2 : Expr
The term "eval e1 env" has type "nat" while it is expected to have type "Z".


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.
File "./ex.v", line 18, characters 19-20:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive AExp : Type :=\n  | ANum (n : Z)\n  | AVar (x : string)\n  | AAdd (e1 e2 : AExp).\n\nFixpoint eval (e : AExp) (env : string -> Z) : Z :=\n  match e with\n  | ANum n => n\n  | AVar x => env x\n  | AAdd e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AAdd (ANum 0) e2 => optimize e2\n  | AAdd e1 (ANum 0) => optimize e1\n  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.
File "./ex.v", line 39, characters 16-22:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.Nat.
File "./ex.v", line 39, characters 16-26:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 39, characters 16-34:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.
File "./ex.v", line 39, characters 16-22:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.ZArith.
File "./ex.v", line 39, characters 16-29:
Error: The reference ZArith.ZArith was not found in the current environment.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.ZArith.add_0_r.
File "./ex.v", line 39, characters 16-37:
Error: The reference ZArith.ZArith.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 36, characters 4-16:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 35, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe1. reflexivity.
File "./ex.v", line 35, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import ZArith.ZArith.

Inductive AExp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nRequire Import Coq.']
['Lists.']
['List.']
['\nRequire Import Coq.']
['Arith.']
['Arith.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 375
number of gen nodes: 188 (including leaves: 63)
number of back nodes: 187 (including leaves: 125)

expansion count: 331 (including failed: 144)

cache stats {'hit': 296, 'miss': 171}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600]

Trial calls: [467]


Time Statistics:

  Min: 600.00 sec, Max: 600.00 sec, Average: 600.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 467 calls, Max: 467 calls, Average: 467.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600]

Trial calls: [467]


Time Statistics:

  Min: 600.00 sec, Max: 600.00 sec, Average: 600.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 467 calls, Max: 467 calls, Average: 467.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, e2 => e2\n    | e1, Const 0 => e1\n    | e1, e2 => Add e1 e2\n    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 47-49:
Error:
In environment
e1, IHe1 : Expr
env : string -> nat
n : nat
e2 : eval (Const n) env = eval e1 env
IHe2 : eval (optimize IHe1) env = eval IHe1 env
The term "e2" has type "eval (Const n) env = eval e1 env"
while it is expected to have type "Expr".


SCORE
-1.0
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 35, characters 4-19:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 32, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 He1 He2].
  - simpl.
File "./ex.v", line 32, characters 17-37:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 He1 He2].\n  - simpl.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 32, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` package com.
SCORE
1.0
['\n``` package com.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` package com.

STATS

number of nodes: 55
number of gen nodes: 28 (including leaves: 6)
number of back nodes: 27 (including leaves: 22)

expansion count: 39 (including failed: 12)

cache stats {'hit': 14, 'miss': 30}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70]

Trial calls: [467, 44]


Time Statistics:

  Min: 70.00 sec, Max: 600.00 sec, Average: 335.00 sec, Standard Deviation: 265.00 sec

Call Statistics:

  Min: 44 calls, Max: 467 calls, Average: 255.50 calls, Standard Deviation: 211.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600]

Trial calls: [467]


Time Statistics:

  Min: 600.00 sec, Max: 600.00 sec, Average: 600.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 467 calls, Max: 467 calls, Average: 467.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70]

Trial calls: [44]


Time Statistics:

  Min: 70.00 sec, Max: 70.00 sec, Average: 70.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 44 calls, Max: 44 calls, Average: 44.00 calls, Standard Deviation: 0.00 calls

Trial  3
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.
File "./ex.v", line 4, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Numbers.


SCORE
None
['Numbers.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.PeanoNat.
File "./ex.v", line 4, characters 0-36:
Error: Cannot find a physical path bound to logical path
Coq.Numbers.PeanoNat.


SCORE
None
['PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.PeanoNat.
Require Import Coq.
File "./ex.v", line 4, characters 0-36:
Error: Cannot find a physical path bound to logical path
Coq.Numbers.PeanoNat.


SCORE
-1.0
['\nRequire Import Coq.']
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.
File "./ex.v", line 4, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.
File "./ex.v", line 6, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.
File "./ex.v", line 6, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.
SCORE
1.0
['\nImport Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : Z -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add e1 (Const 0) => optimize e1\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 33, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 36, characters 4-16:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
['\n  - rewrite IHe1.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2].
  - reflexivity.
File "./ex.v", line 33, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2].\n  - reflexivity.']
['\n  induction e; simpl.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
['add_0_r.']
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 33, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\n  induction e; simpl.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite IHe1.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using Z.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n\nTheorem optimize_preserves_eval :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n x e1 e2]; try constructor; auto.
File "./ex.v", line 33, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2]; try constructor; auto.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 33, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.
File "./ex.v", line 39, characters 97-103:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.Nat.
File "./ex.v", line 39, characters 97-107:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 39, characters 97-115:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
['add_0_r.']
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'

File "./ex.v", line 31, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | _, Const 0 => e1'\n    | Const 0, _ => e2'\n"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.
SCORE
1.0
["    | _, _ => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 39, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
['\n  induction e as [|n x e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl; try reflexivity.
File "./ex.v", line 39, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2].
  - simpl.
File "./ex.v", line 39, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2].\n  - simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 39, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | _, Const 0 => e1'
    | Const 0, _ => e2'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 39, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
['add_0_r.']
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : Expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 18, characters 24-28:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n| Const : Z -> Expr\n| Var : string -> Expr\n| Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
   
File "./ex.v", line 30, characters 3-4:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match (optimize e1), (optimize e2) with\n    | Const 0, _ => e2\n    | _, Const 0 => e1\n    | e1', e2' => Add e1' e2'\n   "]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.
SCORE
1.0
[' end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 37, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 37, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2].\n  - reflexivity.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.
File "./ex.v", line 44, characters 16-22:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.ZArith.
File "./ex.v", line 44, characters 16-29:
Error: The reference ZArith.ZArith was not found in the current environment.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.ZArith.add_0_r.
File "./ex.v", line 44, characters 16-37:
Error: The reference ZArith.ZArith.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using Z.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.Nat.
File "./ex.v", line 44, characters 16-26:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 44, characters 16-34:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.

Inductive Expr : Type :=
| Const : Z -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match (optimize e1), (optimize e2) with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.
File "./ex.v", line 8, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.
File "./ex.v", line 8, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Program.


SCORE
None
['Program.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
SCORE
1.0
['Wf.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.
File "./ex.v", line 9, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.
File "./ex.v", line 9, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Program.


SCORE
None
['Program.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.
SCORE
1.0
['Basics.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Set :=\n  | Const : Z -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition env (s : string) : Z :=
  match s with
    | "x" => 1
    | "y" => 2
    | "z" => 3
    | _ => 0
  end.
File "./ex.v", line 18, characters 6-9:
Error: No interpretation for string "x".


SCORE
-1.0
['\n\nDefinition env (s : string) : Z :=\n  match s with\n    | "x" => 1\n    | "y" => 2\n    | "z" => 3\n    | _ => 0\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 20, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : Expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 35, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2]; simpl.
File "./ex.v", line 35, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 35, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.
File "./ex.v", line 41, characters 97-103:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.Nat.
File "./ex.v", line 41, characters 97-107:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 41, characters 97-115:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.
File "./ex.v", line 42, characters 16-22:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.ZArith.
File "./ex.v", line 42, characters 16-29:
Error: The reference ZArith.ZArith was not found in the current environment.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.ZArith.add_0_r.
File "./ex.v", line 42, characters 16-37:
Error: The reference ZArith.ZArith.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Arith.Arith.
Import Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Program.Basics.

Inductive Expr : Set :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 409
number of gen nodes: 205 (including leaves: 68)
number of back nodes: 204 (including leaves: 137)

expansion count: 352 (including failed: 148)

cache stats {'hit': 239, 'miss': 214}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601]

Trial calls: [467, 44, 453]


Time Statistics:

  Min: 70.00 sec, Max: 601.00 sec, Average: 423.67 sec, Standard Deviation: 250.08 sec

Call Statistics:

  Min: 44 calls, Max: 467 calls, Average: 321.33 calls, Standard Deviation: 196.19 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601]

Trial calls: [467, 453]


Time Statistics:

  Min: 600.00 sec, Max: 601.00 sec, Average: 600.50 sec, Standard Deviation: 0.50 sec

Call Statistics:

  Min: 453 calls, Max: 467 calls, Average: 460.00 calls, Standard Deviation: 7.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70]

Trial calls: [44]


Time Statistics:

  Min: 70.00 sec, Max: 70.00 sec, Average: 70.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 44 calls, Max: 44 calls, Average: 44.00 calls, Standard Deviation: 0.00 calls

Trial  4
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.
File "./ex.v", line 4, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZInt.
File "./ex.v", line 5, characters 7-18:
Error: Cannot find module ZArith.ZInt


SCORE
-1.0
['ZInt.']
['ZInt.']
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
SCORE
1.0
['ZArith_dec.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
SCORE
1.0
['\nImport Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
SCORE
1.0
['\nImport PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.
SCORE
1.0
['\n\nInductive aexp :=\n  | Const (n : Z)\n  | Var (x : string)\n  | Add (e1 e2 : aexp)\n  | Zero.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 20, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : aexp) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  | Zero => 0\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Add e1 e2 =>\n    match e1, e2 with\n    | Zero, _ => optimize e2\n    | _, Zero => optimize e1\n    | _, _ => Add (optimize e1) (optimize e2)\n    end\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2]; simpl.
File "./ex.v", line 39, characters 2-39:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|n |x |e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2]; simpl.
  - reflexivity.
File "./ex.v", line 39, characters 2-39:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2]; simpl.
  - reflexivity.
  - rewrite <- H.
File "./ex.v", line 39, characters 2-39:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 41, characters 15-16:
Error: The variable H was not found in the current environment.


SCORE
-1.0
['\n  - rewrite <- H.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2]; simpl.
  - reflexivity.
  - rewrite H.
File "./ex.v", line 39, characters 2-39:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 41, characters 12-13:
Error: The variable H was not found in the current environment.


SCORE
-1.0
['\n  - rewrite H.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 39, characters 2-39:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 41, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n  - rewrite H.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 |]; simpl.
File "./ex.v", line 39, characters 17-36:
Error: Expects a disjunctive pattern with 4 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 |]; simpl.']
['\n  intros e env.']
['\n  induction e as [| n | x | e1 e2 |]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 39, characters 17-29:
Error: Expects a disjunctive pattern with 4 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - rewrite IHe1.
File "./ex.v", line 40, characters 4-16:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - destruct IHae1; destruct IHae2; try reflexivity.
File "./ex.v", line 40, characters 13-18:
Error: The variable IHae1 was not found in the current environment.


SCORE
-1.0
['\n  - destruct IHae1; destruct IHae2; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x e1 e2]; simpl.
File "./ex.v", line 39, characters 17-27:
Error: Expects a disjunctive pattern with 4 branches.


SCORE
-1.0
['\n  induction e as [|x e1 e2]; simpl.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHa1.
File "./ex.v", line 42, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHa1. rewrite IHa2.
File "./ex.v", line 42, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
[' rewrite IHa2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 45, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 45, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 46, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe1. reflexivity.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\n  induction e; simpl.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHae1.
File "./ex.v", line 41, characters 15-20:
Error: The variable IHae1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHae1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHae1.
    rewrite <- IHae2.
File "./ex.v", line 41, characters 15-20:
Error: The variable IHae1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHae2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHa1.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHa1. reflexivity.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - destruct IHae1; try reflexivity.
File "./ex.v", line 41, characters 13-18:
Error: The variable IHae1 was not found in the current environment.


SCORE
-1.0
['\n  - destruct IHae1; try reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHae1.
File "./ex.v", line 42, characters 12-17:
Error: The variable IHae1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHae1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHae1.
  - rewrite IHae2.
File "./ex.v", line 42, characters 12-17:
Error: The variable IHae1 was not found in the current environment.


SCORE
-1.0
['\n  - rewrite IHae2.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 |].
  - simpl.
File "./ex.v", line 39, characters 17-36:
Error: Expects a disjunctive pattern with 4 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 |].\n  - simpl.']
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Add e1 e2 =>\n    match e1, e2 with\n    | Zero, _ => optimize e2\n    | _, Zero => optimize e1\n    | _, _ => Add (optimize e1) (optimize e2)\n    end\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n\nTheorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 42, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 42, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 43, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 42, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 45, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 45, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 46, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 44, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 45, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\n  - simpl.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. rewrite IHe.
File "./ex.v", line 40, characters 19-22:
Error: The variable IHe was not found in the current environment.


SCORE
None
[' rewrite IHe.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. rewrite IHe. reflexivity.
File "./ex.v", line 40, characters 19-22:
Error: The variable IHe was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite IHe1.
File "./ex.v", line 41, characters 11-23:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
[' rewrite IHe1.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 48, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 48, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 49, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 45, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 45, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 46, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
File "./ex.v", line 39, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|n|x|e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
  - reflexivity.
File "./ex.v", line 39, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
  - reflexivity.
  - exact (env x).
  - rewrite IHe1.
File "./ex.v", line 39, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 41, characters 15-16:
Error: The variable x was not found in the current environment.


SCORE
-1.0
['\n  - exact (env x).\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 39, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 41, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct e0; destruct n; destruct n0;
    try (rewrite IHe1; rewrite IHe2; eauto using PeanoNat.
File "./ex.v", line 43, characters 57-58:
Error: Syntax error: ')' expected after [ltac_expr] (in [ltac_expr]).


SCORE
None
['\n  - destruct e0; destruct n; destruct n0;\n    try (rewrite IHe1; rewrite IHe2; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct e0; destruct n; destruct n0;
    try (rewrite IHe1; rewrite IHe2; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 61-62:
Error: Syntax error: ')' expected after [ltac_expr] (in [ltac_expr]).


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  | Zero => 0
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 e2 =>
    match e1, e2 with
    | Zero, _ => optimize e2
    | _, Zero => optimize e1
    | _, _ => Add (optimize e1) (optimize e2)
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct e0; destruct n; destruct n0;
    try (rewrite IHe1; rewrite IHe2; eauto using PeanoNat.Nat.add_0_r).
  - rewrite IHe; eauto.
File "./ex.v", line 42, characters 13-15:
Error: The variable e0 was not found in the current environment.


SCORE
-1.0
['add_0_r).\n  - rewrite IHe; eauto.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Definition value (e : aexp) (env : string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.
File "./ex.v", line 20, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition value (e : aexp) (env : string -> Z) : Z :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp :=
  | Const (n : Z)
  | Var (x : string)
  | Add (e1 e2 : aexp)
  | Zero.

Definition value (e : aexp) (env : string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (value e1 env) (value e2 env)
    | Zero => 0
  end.
File "./ex.v", line 20, characters 26-38:
Error: Illegal application (Non-functional construction): 
The expression "value e1" of type "option aexp"
cannot be applied to the term
 "env" : "string -> Z"


SCORE
-1.0
['add (value e1 env) (value e2 env)\n    | Zero => 0\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.PeanoNat.
File "./ex.v", line 8, characters 7-24:
Error: Cannot find module PeanoNat.PeanoNat


SCORE
-1.0
['PeanoNat.']
['\nImport Nat.']
['\nImport PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
SCORE
1.0
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.
File "./ex.v", line 9, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.
File "./ex.v", line 9, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Program.


SCORE
None
['Program.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.
SCORE
1.0
['Wf.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 20, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 20, characters 24-35:
Error:
In environment
eval : Expr -> (string -> nat) -> nat
e : Expr
env : string -> nat
e1 : Expr
e2 : Expr
The term "eval e1 env" has type "nat" while it is expected to have type "Z".


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z
File "./ex.v", line 20, characters 21-22:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive aexp : Type :=\n  | ANum (n : Z)\n  | AVar (x : string)\n  | AAdd (e1 e2 : aexp).\n\nFixpoint aval (env : string -> Z) (e : aexp) : Z :=\n  match e with\n    | ANum n => n\n    | AVar x => env x\n    | AAdd e1 e2 => Z']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.
File "./ex.v", line 20, characters 21-22:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.
SCORE
1.0
['add (aval env e1) (aval env e2)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n    | AAdd (ANum 0) e2 => optimize e2\n    | AAdd e1 (ANum 0) => optimize e1\n    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n    | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n\nTheorem optimize_correct : forall env e, aval env (optimize e) = aval env e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  intros env e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe1. reflexivity.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\n  - rewrite IHe1.']
[' reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHe1. reflexivity.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite IHa1.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite IHa1. reflexivity.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e as [| x e1 e2]; simpl.
File "./ex.v", line 34, characters 17-28:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| x e1 e2]; simpl.']
['\n  intros env e.']
['\n  induction e; simpl.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHa1.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHa1.
    rewrite <- IHa2.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHa2.']
['\n  - reflexivity.']
['\n  - rewrite IHa1.']
[' reflexivity.']
['\n  - rewrite <- IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros env e.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHa1. reflexivity.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\n  - rewrite IHe1.']
[' reflexivity.']
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
  induction e as [| n | x | e1 e2]; simpl; try reflexivity.
File "./ex.v", line 34, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - rewrite IHa1.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.Nat.
Require Import Coq.Program.Wf.

Inductive aexp : Type :=
  | ANum (n : Z)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint aval (env : string -> Z) (e : aexp) : Z :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Z.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_correct : forall env e, aval env (optimize e) = aval env e.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - rewrite IHa1. reflexivity.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n  - rewrite IHa1.']
[' reflexivity.']
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.BinNums.
File "./ex.v", line 5, characters 7-21:
Error: Cannot find module ZArith.BinNums


SCORE
-1.0
['BinNums.']
['Require Import Coq.']
['Strings.']
['String.']
['\nRequire Import Coq.']
['Lists.']
['List.']
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.
File "./ex.v", line 4, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Numbers.


SCORE
None
['Numbers.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.PeanoNat.
File "./ex.v", line 4, characters 0-36:
Error: Cannot find a physical path bound to logical path
Coq.Numbers.PeanoNat.


SCORE
None
['PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.PeanoNat.
Require Import Arith.
File "./ex.v", line 4, characters 0-36:
Error: Cannot find a physical path bound to logical path
Coq.Numbers.PeanoNat.


SCORE
-1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 16, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x e1 e2]; simpl.
File "./ex.v", line 31, characters 17-27:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2].
  - simpl.
File "./ex.v", line 31, characters 17-31:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2].\n  - simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x | e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 33, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 33, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 23-25:
Error: The variable e1 was not found in the current environment.


SCORE
-1.0
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 33, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 31, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2]; simpl.
File "./ex.v", line 31, characters 17-31:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2]; simpl.']
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 31, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x | e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 33, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 33, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 23-25:
Error: The variable e1 was not found in the current environment.


SCORE
-1.0
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 33, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl; try reflexivity.
File "./ex.v", line 31, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl; try reflexivity.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 31, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2]; simpl.
File "./ex.v", line 31, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; simpl.']
['\nImport PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.
SCORE
1.0
['\nImport Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : Z -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 20, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 37, characters 4-16:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
['\n  - rewrite IHe1.']
['\n  - reflexivity.']
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x | e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite IHe1. rewrite IHe2.
File "./ex.v", line 36, characters 12-16:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
['\n  - rewrite IHe1.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 34, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith_dec.
Import ListNotations.
Import Nat.
Import PeanoNat.
Import Z.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 377
number of gen nodes: 189 (including leaves: 59)
number of back nodes: 188 (including leaves: 130)

expansion count: 334 (including failed: 146)

cache stats {'hit': 187, 'miss': 266}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601, 604]

Trial calls: [467, 44, 453, 453]


Time Statistics:

  Min: 70.00 sec, Max: 604.00 sec, Average: 468.75 sec, Standard Deviation: 230.22 sec

Call Statistics:

  Min: 44 calls, Max: 467 calls, Average: 354.25 calls, Standard Deviation: 179.21 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601, 604]

Trial calls: [467, 453, 453]


Time Statistics:

  Min: 600.00 sec, Max: 604.00 sec, Average: 601.67 sec, Standard Deviation: 1.70 sec

Call Statistics:

  Min: 453 calls, Max: 467 calls, Average: 457.67 calls, Standard Deviation: 6.60 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70]

Trial calls: [44]


Time Statistics:

  Min: 70.00 sec, Max: 70.00 sec, Average: 70.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 44 calls, Max: 44 calls, Average: 44.00 calls, Standard Deviation: 0.00 calls

Trial  5
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.
File "./ex.v", line 5, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.
File "./ex.v", line 5, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.
SCORE
1.0
['\n\nFixpoint evaluate (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => evaluate e1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'

File "./ex.v", line 29, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | Const 0, _ => e2'\n    | _, Const 0 => e1'\n"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.
SCORE
1.0
["    | _, _ => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 37, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHexpr1.
File "./ex.v", line 41, characters 12-19:
Error: The variable IHexpr1 was not found in the current environment.


SCORE
None
['\n    rewrite IHexpr1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHexpr1.
    rewrite IHexpr2.
File "./ex.v", line 41, characters 12-19:
Error: The variable IHexpr1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite IHexpr2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` package com.
SCORE
1.0
['\n``` package com.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` package com.

STATS

number of nodes: 39
number of gen nodes: 20 (including leaves: 1)
number of back nodes: 19 (including leaves: 19)

expansion count: 21 (including failed: 2)

cache stats {'hit': 0, 'miss': 31}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601, 604, 48]

Trial calls: [467, 44, 453, 453, 31]


Time Statistics:

  Min: 48.00 sec, Max: 604.00 sec, Average: 384.60 sec, Standard Deviation: 265.95 sec

Call Statistics:

  Min: 31 calls, Max: 467 calls, Average: 289.60 calls, Standard Deviation: 205.94 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601, 604]

Trial calls: [467, 453, 453]


Time Statistics:

  Min: 600.00 sec, Max: 604.00 sec, Average: 601.67 sec, Standard Deviation: 1.70 sec

Call Statistics:

  Min: 453 calls, Max: 467 calls, Average: 457.67 calls, Standard Deviation: 6.60 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70, 48]

Trial calls: [44, 31]


Time Statistics:

  Min: 48.00 sec, Max: 70.00 sec, Average: 59.00 sec, Standard Deviation: 11.00 sec

Call Statistics:

  Min: 31 calls, Max: 44 calls, Average: 37.50 calls, Standard Deviation: 6.50 calls

Trial  6
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.
SCORE
1.0
['\n\nFixpoint evaluate (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => evaluate e1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add e1 (Const 0) => optimize e1\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 34, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|x|e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 32, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 32, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 32, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. reflexivity.
File "./ex.v", line 32, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' reflexivity.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|x |e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 32, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 32, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimizer (e : expr) : expr :=\n  match e with\n  | Add (Const 0) e2 => optimizer e2\n  | Add e1 (Const 0) => optimizer e1\n  | Add e1 e2 => Add (optimizer e1) (optimizer e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  evaluate (optimizer e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2].
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|x|e1 e2 IHe1 IHe2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 32, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x|e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 32, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
File "./ex.v", line 34, characters 14-22:
Error: The variable optimize was not found in the current environment.


SCORE
-1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 34, characters 14-22:
Error: The variable optimize was not found in the current environment.


SCORE
-1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 14-22:
Error: The variable optimize was not found in the current environment.


SCORE
-1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 14-22:
Error: The variable optimize was not found in the current environment.


SCORE
-1.0
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimizer (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimizer e2
  | Add e1 (Const 0) => optimizer e1
  | Add e1 e2 => Add (optimizer e1) (optimizer e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimizer e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 55-63:
Error: The variable optimize was not found in the current environment.


SCORE
-1.0
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n\nTheorem optimize_preserves_evaluate : forall e env,\n  evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_evaluate): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_evaluate): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_evaluate): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_evaluate): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.
File "./ex.v", line 15, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 15, characters 17-24:
Error: The reference nat.add was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 15, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, e2 => e2\n    | e1, Const 0 => e1\n    | e1, e2 => Add e1 e2\n    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n\nTheorem optimize_preserves_evaluate : forall e env,\n    evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` #ifndef __CROS_EC_BOARD_H
#define __CROS_EC_BOARD_H

#include "baseboard.
SCORE
1.0
['\n``` #ifndef __CROS_EC_BOARD_H\n#define __CROS_EC_BOARD_H\n\n#include "baseboard.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` #ifndef __CROS_EC_BOARD_H
#define __CROS_EC_BOARD_H

#include "baseboard.

STATS

number of nodes: 349
number of gen nodes: 175 (including leaves: 57)
number of back nodes: 174 (including leaves: 118)

expansion count: 297 (including failed: 123)

cache stats {'hit': 224, 'miss': 181}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601, 604, 48, 490]

Trial calls: [467, 44, 453, 453, 31, 405]


Time Statistics:

  Min: 48.00 sec, Max: 604.00 sec, Average: 402.17 sec, Standard Deviation: 245.93 sec

Call Statistics:

  Min: 31 calls, Max: 467 calls, Average: 308.83 calls, Standard Deviation: 192.86 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601, 604]

Trial calls: [467, 453, 453]


Time Statistics:

  Min: 600.00 sec, Max: 604.00 sec, Average: 601.67 sec, Standard Deviation: 1.70 sec

Call Statistics:

  Min: 453 calls, Max: 467 calls, Average: 457.67 calls, Standard Deviation: 6.60 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70, 48, 490]

Trial calls: [44, 31, 405]


Time Statistics:

  Min: 48.00 sec, Max: 490.00 sec, Average: 202.67 sec, Standard Deviation: 203.37 sec

Call Statistics:

  Min: 31 calls, Max: 405 calls, Average: 160.00 calls, Standard Deviation: 173.32 calls

Trial  7
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
SCORE
1.0
['\nImport List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
   
File "./ex.v", line 29, characters 3-4:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | Const 0, _ => e2'\n    | _, Const 0 => e1'\n    | _, _ => Add e1' e2'\n   "]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.
SCORE
1.0
[' end\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n\nTheorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
``` import { useState, useEffect } from "react";
import { useHistory } from "react-router-dom";
import { useSelector } from "react-redux";
import axios from "axios";
import { RootState } from "../redux/store";
import { API_BASE_URL } from "../constant";
import { toast } from "react-toastify";

const useAuth =
SCORE
1.0
['\n``` import { useState, useEffect } from "react";\nimport { useHistory } from "react-router-dom";\nimport { useSelector } from "react-redux";\nimport axios from "axios";\nimport { RootState } from "../redux/store";\nimport { API_BASE_URL } from "../constant";\nimport { toast } from "react-toastify";\n\nconst useAuth =']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
``` import { useState, useEffect } from "react";
import { useHistory } from "react-router-dom";
import { useSelector } from "react-redux";
import axios from "axios";
import { RootState } from "../redux/store";
import { API_BASE_URL } from "../constant";
import { toast } from "react-toastify";

const useAuth =

STATS

number of nodes: 41
number of gen nodes: 21 (including leaves: 1)
number of back nodes: 20 (including leaves: 20)

expansion count: 20 (including failed: 0)

cache stats {'hit': 0, 'miss': 27}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601, 604, 48, 490, 50]

Trial calls: [467, 44, 453, 453, 31, 405, 27]


Time Statistics:

  Min: 48.00 sec, Max: 604.00 sec, Average: 351.86 sec, Standard Deviation: 258.90 sec

Call Statistics:

  Min: 27 calls, Max: 467 calls, Average: 268.57 calls, Standard Deviation: 203.98 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601, 604]

Trial calls: [467, 453, 453]


Time Statistics:

  Min: 600.00 sec, Max: 604.00 sec, Average: 601.67 sec, Standard Deviation: 1.70 sec

Call Statistics:

  Min: 453 calls, Max: 467 calls, Average: 457.67 calls, Standard Deviation: 6.60 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70, 48, 490, 50]

Trial calls: [44, 31, 405, 27]


Time Statistics:

  Min: 48.00 sec, Max: 490.00 sec, Average: 164.50 sec, Standard Deviation: 188.12 sec

Call Statistics:

  Min: 27 calls, Max: 405 calls, Average: 126.75 calls, Standard Deviation: 160.77 calls

Trial  8
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 14, characters 26-30:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.
SCORE
1.0
["\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, _ => e2\n    | _, Const 0 => e1\n    | e1', e2' => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n\nTheorem optimize_preserves_evaluate : forall e env,\n    evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 33, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 33, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 He1 He2].
  - reflexivity.
File "./ex.v", line 33, characters 17-37:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 He1 He2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x e1 e2].
  - simpl.
File "./ex.v", line 33, characters 17-27:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x e1 e2].\n  - simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 33, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 35, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 35, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 36, characters 4-19:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate e env = evaluate (optimize e) env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [| n x e1 e2]; simpl.
File "./ex.v", line 33, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 36, characters 4-19:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 35, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 35, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 35, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.
SCORE
1.0
['\n\nInductive AExp :=\n| Const : nat -> AExp\n| Var : string -> AExp\n| Add : AExp -> AExp -> AExp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : AExp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, e2 => e2\n    | e1, Const 0 => e1\n    | e1, e2 => Add e1 e2\n    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 33, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 33, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 47-49:
Error:
In environment
e1, IHe1 : AExp
env : string -> nat
n : nat
e2 : eval (Const n) env = eval e1 env
IHe2 : eval (optimize IHe1) env = eval IHe1 env
The term "e2" has type "eval (Const n) env = eval e1 env"
while it is expected to have type "AExp".


SCORE
-1.0
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 37, characters 4-19:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 36, characters 11-26:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
[' rewrite <- IHe1.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 36, characters 4-19:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
```

This script defines an ADT for arithmetic expressions, an evaluator, an optimizer, and a proof that the optimizer preserves the semantics of the expressions.
SCORE
1.0
['\n```\n\nThis script defines an ADT for arithmetic expressions, an evaluator, an optimizer, and a proof that the optimizer preserves the semantics of the expressions.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExp :=
| Const : nat -> AExp
| Var : string -> AExp
| Add : AExp -> AExp -> AExp.

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
```

This script defines an ADT for arithmetic expressions, an evaluator, an optimizer, and a proof that the optimizer preserves the semantics of the expressions.

STATS

number of nodes: 107
number of gen nodes: 54 (including leaves: 13)
number of back nodes: 53 (including leaves: 41)

expansion count: 89 (including failed: 36)

cache stats {'hit': 40, 'miss': 63}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601, 604, 48, 490, 50, 160]

Trial calls: [467, 44, 453, 453, 31, 405, 27, 103]


Time Statistics:

  Min: 48.00 sec, Max: 604.00 sec, Average: 327.88 sec, Standard Deviation: 250.35 sec

Call Statistics:

  Min: 27 calls, Max: 467 calls, Average: 247.88 calls, Standard Deviation: 198.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601, 604]

Trial calls: [467, 453, 453]


Time Statistics:

  Min: 600.00 sec, Max: 604.00 sec, Average: 601.67 sec, Standard Deviation: 1.70 sec

Call Statistics:

  Min: 453 calls, Max: 467 calls, Average: 457.67 calls, Standard Deviation: 6.60 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70, 48, 490, 50, 160]

Trial calls: [44, 31, 405, 27, 103]


Time Statistics:

  Min: 48.00 sec, Max: 490.00 sec, Average: 163.60 sec, Standard Deviation: 168.27 sec

Call Statistics:

  Min: 27 calls, Max: 405 calls, Average: 122.00 calls, Standard Deviation: 144.11 calls

Trial  9
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.
File "./ex.v", line 4, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e
File "./ex.v", line 16, characters 28-29:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive AExp : Type :=\n  | ANum (n : nat)\n  | AVar (x : string)\n  | AAdd (e1 e2 : AExp).\n\nFixpoint evaluate (e : AExp) (env : string -> nat) : nat :=\n  match e with\n  | ANum n => n\n  | AVar x => env x\n  | AAdd e1 e2 => evaluate e']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.
SCORE
1.0
['1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AAdd (ANum 0) e2 => optimize e2\n  | AAdd e1 (ANum 0) => optimize e1\n  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 31, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2]; simpl.
File "./ex.v", line 31, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 34, characters 4-16:
Error:
Found no subterm matching "evaluate (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe.
File "./ex.v", line 33, characters 12-15:
Error: The variable IHe was not found in the current environment.


SCORE
None
['\n  - rewrite IHe.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - rewrite IHe.
  - rewrite IHe.
File "./ex.v", line 33, characters 12-15:
Error: The variable IHe was not found in the current environment.


SCORE
-1.0
['\n  - rewrite IHe.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 33-41:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 33-45:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 35, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - destruct e0; simpl.
File "./ex.v", line 35, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - destruct e0; simpl.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 31, characters 2-50:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| n x | e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
File "./ex.v", line 31, characters 2-50:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - exact (env x).
  - rewrite <- IHe1.
File "./ex.v", line 31, characters 2-50:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
File "./ex.v", line 33, characters 15-16:
Error: The variable x was not found in the current environment.


SCORE
-1.0
['\n  - exact (env x).\n  - rewrite <- IHe1.']
['\n  - exact (env x).\n  - rewrite <- IHe1.']
['\nQed.']
['\n  - reflexivity.']
['\n  - exact (env x).\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 34, characters 4-16:
Error:
Found no subterm matching "evaluate (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AAdd (ANum 0) e2 => optimize e2\n  | AAdd e1 (ANum 0) => optimize e1\n  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n  | _ => e\n  end.']
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
['\nProof.']
['\n  intros e env.']
['\n  induction e; simpl.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

Inductive AExp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : AExp).

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - exact (env x).\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.
SCORE
1.0
['\n\nFixpoint evaluate (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => evaluate e1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    |
File "./ex.v", line 28, characters 5-6:
Error: Syntax error: [eqn] expected after '|' (in [branches]).


SCORE
None
["\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | Const 0, _ => e2'\n    | _, Const 0 => e1'\n    |"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.
SCORE
1.0
[" _, _ => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n\nTheorem optimize_preserves_evaluate : forall e env,\n  evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; try reflexivity.
File "./ex.v", line 36, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x n e1 e2]; simpl.
File "./ex.v", line 36, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x n e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 36, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 36, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 36, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.']
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl; try reflexivity.
File "./ex.v", line 36, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` 

import React, { Component } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  Dimensions,
  Platform,
  Alert,
  Linking,
} from 'react-native';
import { WebView } from 'react-native-webview';
import { connect } from 'react-redux';
import { bindActionCreators
SCORE
1.0
["\n``` \n\nimport React, { Component } from 'react';\nimport {\n  StyleSheet,\n  Text,\n  View,\n  TouchableOpacity,\n  Dimensions,\n  Platform,\n  Alert,\n  Linking,\n} from 'react-native';\nimport { WebView } from 'react-native-webview';\nimport { connect } from 'react-redux';\nimport { bindActionCreators"]
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` 

import React, { Component } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  Dimensions,
  Platform,
  Alert,
  Linking,
} from 'react-native';
import { WebView } from 'react-native-webview';
import { connect } from 'react-redux';
import { bindActionCreators

STATS

number of nodes: 287
number of gen nodes: 144 (including leaves: 46)
number of back nodes: 143 (including leaves: 98)

expansion count: 247 (including failed: 104)

cache stats {'hit': 196, 'miss': 142}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601, 604, 48, 490, 50, 160, 435]

Trial calls: [467, 44, 453, 453, 31, 405, 27, 103, 338]


Time Statistics:

  Min: 48.00 sec, Max: 604.00 sec, Average: 339.78 sec, Standard Deviation: 238.42 sec

Call Statistics:

  Min: 27 calls, Max: 467 calls, Average: 257.89 calls, Standard Deviation: 189.28 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601, 604]

Trial calls: [467, 453, 453]


Time Statistics:

  Min: 600.00 sec, Max: 604.00 sec, Average: 601.67 sec, Standard Deviation: 1.70 sec

Call Statistics:

  Min: 453 calls, Max: 467 calls, Average: 457.67 calls, Standard Deviation: 6.60 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70, 48, 490, 50, 160, 435]

Trial calls: [44, 31, 405, 27, 103, 338]


Time Statistics:

  Min: 48.00 sec, Max: 490.00 sec, Average: 208.83 sec, Standard Deviation: 183.92 sec

Call Statistics:

  Min: 27 calls, Max: 405 calls, Average: 158.00 calls, Standard Deviation: 154.23 calls

Trial  10
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Definition eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => nat.
File "./ex.v", line 14, characters 22-23:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Definition eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 14, characters 19-26:
Error: The reference nat.add was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 31, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 31, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 32, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 32, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 32, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 33, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 33, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  induction e.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; try reflexivity.
File "./ex.v", line 28, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; try reflexivity.']
['\n  induction e.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2].
  - simpl.
File "./ex.v", line 28, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|x |e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 30, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 30, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x | e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 30, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2]; simpl.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 30, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n  - rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl; try reflexivity.
File "./ex.v", line 28, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl; try reflexivity.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2].
  - reflexivity.
File "./ex.v", line 28, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.
File "./ex.v", line 4, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.BinNums.
File "./ex.v", line 5, characters 7-21:
Error: Cannot find module ZArith.BinNums


SCORE
-1.0
['BinNums.']
['BinNums.']
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.
File "./ex.v", line 6, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.
File "./ex.v", line 6, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Program.


SCORE
None
['Program.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
SCORE
1.0
['Basics.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.
File "./ex.v", line 7, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.
File "./ex.v", line 7, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Program.


SCORE
None
['Program.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.
SCORE
1.0
['Wf.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : Z -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 18, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.
SCORE
1.0
["\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, _ => e2\n    | _, Const 0 => e1\n    | e1', e2' => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n\nTheorem optimize_correct : forall e env,\n  evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using ZArith.
File "./ex.v", line 45, characters 16-22:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using ZArith.Nat.
File "./ex.v", line 45, characters 16-26:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 45, characters 16-34:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:  (in proof optimize_correct): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:  (in proof optimize_correct): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:  (in proof optimize_correct): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
File "./ex.v", line 41, characters 4-16:
Error:
Found no subterm matching "evaluate (optimize e1) env" in the current goal.


SCORE
-1.0
['\n    rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 40, characters 4-16:
Error:
Found no subterm matching "evaluate (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
['\n  - reflexivity.']
['\n  - reflexivity.']
['\n  - simpl.']
['\n    rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using Z.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:  (in proof optimize_correct): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_correct.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:  (in proof optimize_correct): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
['add_0_r.']
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHexpr1.
File "./ex.v", line 40, characters 12-19:
Error: The variable IHexpr1 was not found in the current environment.


SCORE
None
['\n  - rewrite IHexpr1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHexpr1.
    rewrite IHexpr2.
File "./ex.v", line 40, characters 12-19:
Error: The variable IHexpr1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite IHexpr2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 37, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Wf.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint evaluate (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_correct : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x e1 e2]; simpl.
File "./ex.v", line 37, characters 17-27:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x e1 e2]; simpl.']
['\nProof.']
['\n  intros e env.']
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\n  induction e; simpl.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 463
number of gen nodes: 232 (including leaves: 81)
number of back nodes: 231 (including leaves: 151)

expansion count: 407 (including failed: 176)

cache stats {'hit': 433, 'miss': 127}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 70, 601, 604, 48, 490, 50, 160, 435, 600]

Trial calls: [467, 44, 453, 453, 31, 405, 27, 103, 338, 560]


Time Statistics:

  Min: 48.00 sec, Max: 604.00 sec, Average: 365.80 sec, Standard Deviation: 239.28 sec

Call Statistics:

  Min: 27 calls, Max: 560 calls, Average: 288.10 calls, Standard Deviation: 201.15 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [600, 601, 604, 600]

Trial calls: [467, 453, 453, 560]


Time Statistics:

  Min: 600.00 sec, Max: 604.00 sec, Average: 601.25 sec, Standard Deviation: 1.64 sec

Call Statistics:

  Min: 453 calls, Max: 560 calls, Average: 483.25 calls, Standard Deviation: 44.68 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [70, 48, 490, 50, 160, 435]

Trial calls: [44, 31, 405, 27, 103, 338]


Time Statistics:

  Min: 48.00 sec, Max: 490.00 sec, Average: 208.83 sec, Standard Deviation: 183.92 sec

Call Statistics:

  Min: 27 calls, Max: 405 calls, Average: 158.00 calls, Standard Deviation: 154.23 calls

To complete all experiments, 61 minutes and 33 seconds elapsed.


