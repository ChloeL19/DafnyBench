

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 6 --language Dafny --problem_name problem_bst --seed 42 


[2024-01-11 14:53:54,243] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Define the ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.

SCORE
1.0
['// (2) Define a predicate that checks whether a given tree is a binary search tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['function IsBST(t: Tree, lower: nat, upper: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
10 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
11 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
12 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(12,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.

SCORE
1.0
['// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)

   |
18 |   if t == Empty then Node(Empty, value, Empty)
   |                                               ^

ex.dfy(18,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else

   |
19 |   else
   |       ^

ex.dfy(19,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t

   |
20 |     match t
   |            ^

ex.dfy(20,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>

   |
21 |     case Node(left, t_value, right) =>
   |                                       ^

ex.dfy(21,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, t_value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)

   |
22 |       if value < t_value then Node(Insert(left, value), t_value, right)
   |                                                                        ^

ex.dfy(22,71): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < t_value then Node(Insert(left, value), t_value, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))

   |
23 |       else if value > t_value then Node(left, t_value, Insert(right, value))
   |                                                                             ^

ex.dfy(23,76): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > t_value then Node(left, t_value, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t

   |
24 |       else t
   |             ^

ex.dfy(24,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.

SCORE
1.0
['// (4) Define a predicate that checks whether a given tree contains a given element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t

   |
30 |   match t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false

   |
31 |   case Empty => false
   |                      ^

ex.dfy(31,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>

   |
32 |   case Node(left, t_value, right) =>
   |                                     ^

ex.dfy(32,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, t_value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)

   |
33 |     if value < t_value then Contains(left, value)
   |                                                  ^

ex.dfy(33,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < t_value then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)

   |
34 |     else if value > t_value then Contains(right, value)
   |                                                        ^

ex.dfy(34,55): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > t_value then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true

   |
35 |     else true
   |              ^

ex.dfy(35,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
42 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(42,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.

   |
43 |   // Base case: if t is Empty, then the result of Insert is a Node containing value.
   |                                                                                     ^

ex.dfy(43,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
44 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(44,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
45 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(45,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.

   |
53 |   // Proof by structural induction on t, with lower and upper as induction hypotheses.
   |                                                                                       ^

ex.dfy(53,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, with lower and upper as induction hypotheses.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.

   |
55 |   // and the BST property holds because there are no other elements.
   |                                                                     ^

ex.dfy(55,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and the BST property holds because there are no other elements.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In either case,

   |
57 |   // or recursively calls Insert on left or right subtree. In either case,
   |                                                                           ^

ex.dfy(57,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. In either case,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In either case,
  // the BST property holds because of the induction hypotheses on left and right.

   |
58 |   // the BST property holds because of the induction hypotheses on left and right.
   |                                                                                   ^

ex.dfy(58,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // the BST property holds because of the induction hypotheses on left and right.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In either case,
  // the BST property holds because of the induction hypotheses on left and right.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.

   |
53 |   // Proof by structural induction on t, with the bounds lower and upper.
   |                                                                          ^

ex.dfy(53,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, with the bounds lower and upper.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.

   |
55 |   // which preserves the BST property within the bounds.
   |                                                         ^

ex.dfy(55,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property within the bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, which preserves the BST property

   |
57 |   // or recursively calls Insert on left or right subtree, which preserves the BST property
   |                                                                                            ^

ex.dfy(57,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree, which preserves the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, which preserves the BST property
  // within the updated bounds.

   |
58 |   // within the updated bounds.
   |                                ^

ex.dfy(58,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // within the updated bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, which preserves the BST property
  // within the updated bounds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.

   |
53 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(53,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
   |                                                                                                  ^

ex.dfy(54,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,
   |                                                                                                                 ^

ex.dfy(55,112): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.

   |
55 |   // which satisfies the BST property with any bounds.
   |                                                       ^

ex.dfy(55,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property with any bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property is preserved

   |
57 |   // or recursively calls Insert on left or right subtree. The BST property is preserved
   |                                                                                         ^

ex.dfy(57,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. The BST property is preserved\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property is preserved
  // by the recursive calls and the ordering of value relative to t_value.

   |
58 |   // by the recursive calls and the ordering of value relative to t_value.
   |                                                                           ^

ex.dfy(58,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // by the recursive calls and the ordering of value relative to t_value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property is preserved
  // by the recursive calls and the ordering of value relative to t_value.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.

   |
55 |   // and the BST property holds because it is a single node.
   |                                                             ^

ex.dfy(55,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and the BST property holds because it is a single node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.

   |
57 |   // or recursively calls Insert on left or right subtree. In each case, the BST property holds.
   |                                                                                                 ^

ex.dfy(57,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
   |                                                                                                                       ^

ex.dfy(54,118): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(55,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.

   |
56 |   // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.
   |                                                                                                                     ^

ex.dfy(56,116): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
['  // and the BST property holds because it is a single node.\n']
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
['  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.

   |
53 |   // Proof by structural induction on t, similar to the previous lemma.
   |                                                                        ^

ex.dfy(53,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, similar to the previous lemma.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.

   |
55 |   // which preserves the BST property.
   |                                       ^

ex.dfy(55,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.

   |
55 |   // which satisfies the BST property.
   |                                       ^

ex.dfy(55,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // The BST property is preserved if the recursive calls also preserve the property.

   |
58 |   // The BST property is preserved if the recursive calls also preserve the property.
   |                                                                                      ^

ex.dfy(58,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // The BST property is preserved if the recursive calls also preserve the property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // The BST property is preserved if the recursive calls also preserve the property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.

   |
55 |   // which preserves the BST property because it is a single node.
   |                                                                   ^

ex.dfy(55,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property because it is a single node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.

   |
54 |   // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
   |                                                                                           ^

ex.dfy(54,90): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
  // Inductive step: if t is a Node, then Insert either maintains the BST property,

   |
55 |   // Inductive step: if t is a Node, then Insert either maintains the BST property,
   |                                                                                    ^

ex.dfy(55,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either maintains the BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
  // Inductive step: if t is a Node, then Insert either maintains the BST property,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
  // Inductive step: if t is a Node, then Insert either maintains the BST property,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.

   |
55 |   // which preserves the BST property because it is a single-node tree.
   |                                                                        ^

ex.dfy(55,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property because it is a single-node tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The lemma should be proved

   |
57 |   // or recursively calls Insert on left or right subtree. The lemma should be proved
   |                                                                                      ^

ex.dfy(57,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. The lemma should be proved\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The lemma should be proved
  // by recursively calling itself on the subtrees and checking the BST property.

   |
58 |   // by recursively calling itself on the subtrees and checking the BST property.
   |                                                                                  ^

ex.dfy(58,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // by recursively calling itself on the subtrees and checking the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The lemma should be proved
  // by recursively calling itself on the subtrees and checking the BST property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.

   |
55 |   // which satisfies the BST property with respect to lower and upper.
   |                                                                       ^

ex.dfy(55,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property with respect to lower and upper.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 65
number of gen nodes: 33 (including leaves: 6)
number of back nodes: 32 (including leaves: 27)

expansion count: 45 (including failed: 13)

cache stats {'hit': 39, 'miss': 113}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374]

Trial calls: [152]


Time Statistics:

  Min: 374.00 sec, Max: 374.00 sec, Average: 374.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 152 calls, Max: 152 calls, Average: 152.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374]

Trial calls: [152]


Time Statistics:

  Min: 374.00 sec, Max: 374.00 sec, Average: 374.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 152 calls, Max: 152 calls, Average: 152.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Define an ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.

SCORE
1.0
['// (2) Define a predicate to check if a tree is a binary search tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>

   |
11 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(11,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&

   |
12 |     v >= min && v <= max &&
   |                            ^

ex.dfy(12,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&

   |
13 |     IsBST(l, min, v) &&
   |                        ^

ex.dfy(13,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)

   |
14 |     IsBST(r, v, max)
   |                     ^

ex.dfy(14,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.

SCORE
1.0
['// (3) Define a function to insert an element into a binary search tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then

   |
20 |   if t == Empty then
   |                     ^

ex.dfy(20,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)

   |
21 |     Node(Empty, v, Empty)
   |                          ^

ex.dfy(21,25): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else

   |
22 |   else
   |       ^

ex.dfy(22,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t

   |
23 |     match t
   |            ^

ex.dfy(23,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>

   |
24 |     case Node(l, w, r) =>
   |                          ^

ex.dfy(24,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then

   |
25 |       if v < w then
   |                    ^

ex.dfy(25,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)

   |
26 |         Node(Insert(l, v), w, r)
   |                                 ^

ex.dfy(26,32): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(l, v), w, r)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else

   |
27 |       else
   |           ^

ex.dfy(27,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))

   |
28 |         Node(l, w, Insert(r, v))
   |                                 ^

ex.dfy(28,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(l, w, Insert(r, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.

SCORE
1.0
['// (4) Define a predicate to check if a tree contains a given element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{

   |
33 | {
   |  ^

ex.dfy(33,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t

   |
34 |   match t
   |          ^

ex.dfy(34,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false

   |
35 |   case Empty => false
   |                      ^

ex.dfy(35,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>

   |
36 |   case Node(l, w, r) =>
   |                        ^

ex.dfy(36,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)

   |
37 |     if v < w then Contains(l, v)
   |                                 ^

ex.dfy(37,32): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < w then Contains(l, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)

   |
38 |     else if v > w then Contains(r, v)
   |                                      ^

ex.dfy(38,37): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if v > w then Contains(r, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true

   |
39 |     else true
   |              ^

ex.dfy(39,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.

SCORE
1.0
['// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)

SCORE
1.0
['  ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.

   |
46 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(46,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  if t == Empty then

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  if t == Empty then
    // Base case: If t is empty, then the result of inserting v is a singleton tree containing v.

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: If t is empty, then the result of inserting v is a singleton tree containing v.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  if t == Empty then
    // Base case: If t is empty, then the result of inserting v is a singleton tree containing v.
    assert Contains(Node(Empty, v, Empty), v);

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert Contains(Node(Empty, v, Empty), v);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.

   |
46 |   // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
   |                                                                                     ^

ex.dfy(46,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {

   |
47 |   if t == Empty {
   |                  ^

ex.dfy(47,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);

   |
48 |     assert Contains(Node(Empty, v, Empty), v);
   |                                               ^

ex.dfy(48,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Empty, v, Empty), v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {

   |
49 |   } else {
   |           ^

ex.dfy(49,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).

   |
50 |     // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
   |                                                                                                               ^

ex.dfy(50,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).

   |
51 |     // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
   |                                                                                                               ^

ex.dfy(51,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t

   |
52 |     match t
   |            ^

ex.dfy(52,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>

   |
53 |     case Node(l, w, r) =>
   |                          ^

ex.dfy(53,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {

   |
54 |       if v < w {
   |                 ^

ex.dfy(54,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);

   |
55 |         assert Contains(Insert(l, v), v);
   |                                          ^

ex.dfy(55,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Insert(l, v), v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {

   |
56 |       } else {
   |               ^

ex.dfy(56,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);

   |
57 |         assert Contains(Insert(r, v), v);
   |                                          ^

ex.dfy(57,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Insert(r, v), v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }

   |
58 |       }
   |        ^

ex.dfy(58,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }

   |
59 |   }
   |    ^

ex.dfy(59,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property holds after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, v), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{

   |
66 | {
   |  ^

ex.dfy(66,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.

   |
67 |   // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
   |                                                                                                     ^

ex.dfy(67,100): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {

   |
68 |   if t == Empty {
   |                  ^

ex.dfy(68,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);

   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |                                                   ^

ex.dfy(69,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert IsBST(Node(Empty, v, Empty), min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {

   |
70 |   } else {
   |           ^

ex.dfy(70,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).

   |
71 |     // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
   |                                                                                                               ^

ex.dfy(71,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).

   |
72 |     // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
   |                                                                                                               ^

ex.dfy(72,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t

   |
73 |     match t
   |            ^

ex.dfy(73,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>

   |
74 |     case Node(l, w, r) =>
   |                          ^

ex.dfy(74,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {

   |
75 |       if v < w {
   |                 ^

ex.dfy(75,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);

   |
76 |         assert IsBST(Insert(l, v), min, w);
   |                                            ^

ex.dfy(76,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Insert(l, v), min, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {

   |
77 |       } else {
   |               ^

ex.dfy(77,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);

   |
78 |         assert IsBST(Insert(r, v), w, max);
   |                                            ^

ex.dfy(78,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Insert(r, v), w, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }

   |
79 |       }
   |        ^

ex.dfy(79,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }
  }

   |
80 |   }
   |    ^

ex.dfy(80,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }
  }
}

ex.dfy(69,11): Error: assertion might not hold
   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,16): Related location
   |
12 |     v >= min && v <= max &&
   |                 ^^^^^^^^

ex.dfy(69,11): Error: assertion might not hold
   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     v >= min && v <= max &&
   |     ^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.

   |
67 |   // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
   |                                                                                     ^

ex.dfy(67,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {

   |
68 |   if t == Empty {
   |                  ^

ex.dfy(68,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);

   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |                                                   ^

ex.dfy(69,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert IsBST(Node(Empty, v, Empty), min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {

   |
70 |   } else {
   |           ^

ex.dfy(70,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).

   |
71 |     // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
   |                                                                                                               ^

ex.dfy(71,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).

   |
72 |     // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
   |                                                                                                               ^

ex.dfy(72,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t

   |
73 |     match t
   |            ^

ex.dfy(73,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>

   |
74 |     case Node(l, w, r) =>
   |                          ^

ex.dfy(74,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {

   |
75 |       if v < w {
   |                 ^

ex.dfy(75,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);

   |
76 |         assert IsBST(Insert(l, v), min, w);
   |                                            ^

ex.dfy(76,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Insert(l, v), min, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {

   |
77 |       } else {
   |               ^

ex.dfy(77,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);

   |
78 |         assert IsBST(Insert(r, v), w, max);
   |                                            ^

ex.dfy(78,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Insert(r, v), w, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }

   |
79 |       }
   |        ^

ex.dfy(79,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }
  }

   |
80 |   }
   |    ^

ex.dfy(80,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }
  }
}

ex.dfy(69,11): Error: assertion might not hold
   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,16): Related location
   |
12 |     v >= min && v <= max &&
   |                 ^^^^^^^^

ex.dfy(69,11): Error: assertion might not hold
   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     v >= min && v <= max &&
   |     ^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, v), min, max)\n']
['{\n']
['  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v, which is a BST.\n']
['  if t == Empty {\n']
['    assert IsBST(Node(Empty, v, Empty), min, max);\n']
['  } else {\n']
['    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).\n']
['    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).\n']
['    match t\n']
['    case Node(l, w, r) =>\n']
['      if v < w {\n']
['        assert IsBST(Insert(l, v), min, w);\n']
['      } else {\n']
['        assert IsBST(Insert(r, v), w, max);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.\n']
['  if t == Empty {\n']
['    assert IsBST(Node(Empty, v, Empty), min, max);\n']
['  } else {\n']
['    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).\n']
['    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).\n']
['    match t\n']
['    case Node(l, w, r) =>\n']
['      if v < w {\n']
['        assert IsBST(Insert(l, v), min, w);\n']
['      } else {\n']
['        assert IsBST(Insert(r, v), w, max);\n']
['      }\n']
['  }\n']
['}\n']
['  requires IsBST(t, min, max)\n']
['  ensures IsBST(Insert(t, v), min, max)\n']
['{\n']
['  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.\n']
['  if t == Empty {\n']
['    assert IsBST(Node(Empty, v, Empty), min, max);\n']
['  } else {\n']
['    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).\n']
['    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).\n']
['    match t\n']
['    case Node(l, w, r) =>\n']
['      if v < w {\n']
['        assert IsBST(Insert(l, v), min, w);\n']
['      } else {\n']
['        assert IsBST(Insert(r, v), w, max);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.

   |
67 |   // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
   |                                                                                        ^

ex.dfy(67,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {

   |
68 |   if t == Empty {
   |                  ^

ex.dfy(68,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);

   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |                                                   ^

ex.dfy(69,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert IsBST(Node(Empty, v, Empty), min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {

   |
70 |   } else {
   |           ^

ex.dfy(70,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).

   |
71 |     // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
   |                                                                                                               ^

ex.dfy(71,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).

   |
72 |     // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
   |                                                                                                               ^

ex.dfy(72,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t

   |
73 |     match t
   |            ^

ex.dfy(73,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>

   |
74 |     case Node(l, w, r) =>
   |                          ^

ex.dfy(74,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {

   |
75 |       if v < w {
   |                 ^

ex.dfy(75,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);

   |
76 |         assert IsBST(Insert(l, v), min, w);
   |                                            ^

ex.dfy(76,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Insert(l, v), min, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {

   |
77 |       } else {
   |               ^

ex.dfy(77,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);

   |
78 |         assert IsBST(Insert(r, v), w, max);
   |                                            ^

ex.dfy(78,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Insert(r, v), w, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }

   |
79 |       }
   |        ^

ex.dfy(79,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }
  }

   |
80 |   }
   |    ^

ex.dfy(80,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree.
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Define a function to insert an element into a binary search tree.
function Insert(t: Tree, v: nat): Tree
{
  if t == Empty then
    Node(Empty, v, Empty)
  else
    match t
    case Node(l, w, r) =>
      if v < w then
        Node(Insert(l, v), w, r)
      else
        Node(l, w, Insert(r, v))
}

// (4) Define a predicate to check if a tree contains a given element.
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    if v < w then Contains(l, v)
    else if v > w then Contains(r, v)
    else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree containing v.
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert Contains(Insert(l, v), v);
      } else {
        assert Contains(Insert(r, v), v);
      }
  }
}

// (6) Lemma about the insert function that checks the BST property holds after insertion.
lemma InsertPreservesIsBST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, v), min, max)
{
  // Base case: if t is Empty, then Insert(t, v) is a single-node tree, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, v, Empty), min, max);
  } else {
    // Recursive case: if v is less than the root of t, then Insert(t, v) is equivalent to Insert(left(t), v).
    // If v is greater than or equal to the root of t, then Insert(t, v) is equivalent to Insert(right(t), v).
    match t
    case Node(l, w, r) =>
      if v < w {
        assert IsBST(Insert(l, v), min, w);
      } else {
        assert IsBST(Insert(r, v), w, max);
      }
  }
}

ex.dfy(69,11): Error: assertion might not hold
   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,16): Related location
   |
12 |     v >= min && v <= max &&
   |                 ^^^^^^^^

ex.dfy(69,11): Error: assertion might not hold
   |
69 |     assert IsBST(Node(Empty, v, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     v >= min && v <= max &&
   |     ^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 57
number of gen nodes: 29 (including leaves: 3)
number of back nodes: 28 (including leaves: 26)

expansion count: 35 (including failed: 7)

cache stats {'hit': 54, 'miss': 115}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371]

Trial calls: [152, 169]


Time Statistics:

  Min: 371.00 sec, Max: 374.00 sec, Average: 372.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 152 calls, Max: 169 calls, Average: 160.50 calls, Standard Deviation: 8.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371]

Trial calls: [152, 169]


Time Statistics:

  Min: 371.00 sec, Max: 374.00 sec, Average: 372.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 152 calls, Max: 169 calls, Average: 160.50 calls, Standard Deviation: 8.50 calls

Trial  3
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Write an ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).

SCORE
1.0
['// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>

   |
10 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&

   |
12 |     value <= max &&
   |                    ^

ex.dfy(12,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&

   |
13 |     value >= min &&
   |                    ^

ex.dfy(13,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)

   |
14 |     IsBST(right, value, max)
   |                             ^

ex.dfy(14,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true

   |
15 |   case Empty => true
   |                     ^

ex.dfy(15,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.

SCORE
1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
21 |   match t
   |          ^

ex.dfy(21,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>

   |
22 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(22,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
23 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(23,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
24 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(24,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
25 |     else t
   |           ^

ex.dfy(25,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)

   |
26 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(26,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.

SCORE
1.0
['// (4) Write a predicate that checks whether a given tree contains a given element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t

   |
32 |   match t
   |          ^

ex.dfy(32,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>

   |
33 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(33,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)

   |
34 |     if value < v then Contains(left, value)
   |                                            ^

ex.dfy(34,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)

   |
35 |     else if value > v then Contains(right, value)
   |                                                  ^

ex.dfy(35,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true

   |
36 |     else true
   |              ^

ex.dfy(36,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false

   |
37 |   case Empty => false
   |                      ^

ex.dfy(37,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).

SCORE
1.0
['// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.

   |
44 |   // Base case: if t is Empty, the result is a new node with the value.
   |                                                                        ^

ex.dfy(44,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, the result is a new node with the value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {

   |
45 |   if t == Empty {
   |                  ^

ex.dfy(45,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);

   |
46 |     assert Contains(Node(Empty, value, Empty), value);
   |                                                       ^

ex.dfy(46,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Empty, value, Empty), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {

   |
47 |   } else {
   |           ^

ex.dfy(47,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.

   |
48 |     // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
   |                                                                                                                               ^

ex.dfy(48,126): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.

   |
49 |     // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
   |                                                                                                                   ^

ex.dfy(49,114): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.

   |
50 |     // If value is equal to the root, the result is the same as the original tree.
   |                                                                                   ^

ex.dfy(50,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is equal to the root, the result is the same as the original tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t

   |
51 |     match t
   |            ^

ex.dfy(51,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>

   |
52 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(52,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {

   |
53 |       if value < v {
   |                     ^

ex.dfy(53,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);

   |
54 |         InsertEnsuresContains(left, value);
   |                                            ^

ex.dfy(54,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {

   |
55 |       } else if value > v {
   |                            ^

ex.dfy(55,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);

   |
56 |         InsertEnsuresContains(right, value);
   |                                             ^

ex.dfy(56,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }

   |
57 |       }
   |        ^

ex.dfy(57,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }

   |
58 |   }
   |    ^

ex.dfy(58,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
65 | {
   |  ^

ex.dfy(65,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.

   |
66 |   // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
   |                                                                                                               ^

ex.dfy(66,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {

   |
67 |   if t == Empty {
   |                  ^

ex.dfy(67,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);

   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |                                                       ^

ex.dfy(68,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert IsBST(Node(Empty, value, Empty), min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {

   |
69 |   } else {
   |           ^

ex.dfy(69,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.

   |
70 |     // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
   |                                                                                                                               ^

ex.dfy(70,126): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.

   |
71 |     // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
   |                                                                                                                   ^

ex.dfy(71,114): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.

   |
72 |     // If value is equal to the root, the result is the same as the original tree.
   |                                                                                   ^

ex.dfy(72,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is equal to the root, the result is the same as the original tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t

   |
73 |     match t
   |            ^

ex.dfy(73,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>

   |
74 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(74,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {

   |
75 |       if value < v {
   |                     ^

ex.dfy(75,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);

   |
76 |         InsertPreservesIsBST(left, value, min, v);
   |                                                   ^

ex.dfy(76,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesIsBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {

   |
77 |       } else if value > v {
   |                            ^

ex.dfy(77,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);

   |
78 |         InsertPreservesIsBST(right, value, v, max);
   |                                                    ^

ex.dfy(78,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesIsBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      } else {

   |
79 |       } else {
   |               ^

ex.dfy(79,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      } else {
        assert IsBST(t, min, max);

   |
80 |         assert IsBST(t, min, max);
   |                                   ^

ex.dfy(80,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(t, min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      } else {
        assert IsBST(t, min, max);
      }

   |
81 |       }
   |        ^

ex.dfy(81,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      } else {
        assert IsBST(t, min, max);
      }
  }

   |
82 |   }
   |    ^

ex.dfy(82,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST if min <= value <= max.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      } else {
        assert IsBST(t, min, max);
      }
  }
}

ex.dfy(68,11): Error: assertion might not hold
   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value >= min &&
   |     ^^^^^^^^^^^^

ex.dfy(68,11): Error: assertion might not hold
   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value <= max &&
   |     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.

   |
66 |   // Base case: if t is Empty, the result is a new node with the value.
   |                                                                        ^

ex.dfy(66,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, the result is a new node with the value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {

   |
67 |   if t == Empty {
   |                  ^

ex.dfy(67,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);

   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |                                                       ^

ex.dfy(68,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert IsBST(Node(Empty, value, Empty), min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {

   |
69 |   } else {
   |           ^

ex.dfy(69,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.

   |
70 |     // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
   |                                                                                                                               ^

ex.dfy(70,126): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.

   |
71 |     // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
   |                                                                                                                   ^

ex.dfy(71,114): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.

   |
72 |     // If value is equal to the root, the result is the same as the original tree.
   |                                                                                   ^

ex.dfy(72,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is equal to the root, the result is the same as the original tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t

   |
73 |     match t
   |            ^

ex.dfy(73,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>

   |
74 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(74,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {

   |
75 |       if value < v {
   |                     ^

ex.dfy(75,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);

   |
76 |         InsertPreservesIsBST(left, value, min, v);
   |                                                   ^

ex.dfy(76,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesIsBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {

   |
77 |       } else if value > v {
   |                            ^

ex.dfy(77,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);

   |
78 |         InsertPreservesIsBST(right, value, v, max);
   |                                                    ^

ex.dfy(78,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesIsBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      }

   |
79 |       }
   |        ^

ex.dfy(79,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      }
  }

   |
80 |   }
   |    ^

ex.dfy(80,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      }
  }
}

ex.dfy(68,11): Error: assertion might not hold
   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value >= min &&
   |     ^^^^^^^^^^^^

ex.dfy(68,11): Error: assertion might not hold
   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value <= max &&
   |     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Base case: if t is Empty, the result is a new node with the value.\n']
['  if t == Empty {\n']
['    assert IsBST(Node(Empty, value, Empty), min, max);\n']
['  } else {\n']
['    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.\n']
['    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.\n']
['    // If value is equal to the root, the result is the same as the original tree.\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesIsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertPreservesIsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.

   |
66 |   // Base case: if t is Empty, the result is a new node with the value, which is a BST.
   |                                                                                        ^

ex.dfy(66,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, the result is a new node with the value, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {

   |
67 |   if t == Empty {
   |                  ^

ex.dfy(67,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);

   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |                                                       ^

ex.dfy(68,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert IsBST(Node(Empty, value, Empty), min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {

   |
69 |   } else {
   |           ^

ex.dfy(69,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.

   |
70 |     // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
   |                                                                                                                               ^

ex.dfy(70,126): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.

   |
71 |     // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
   |                                                                                                                   ^

ex.dfy(71,114): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.

   |
72 |     // If value is equal to the root, the result is the same as the original tree.
   |                                                                                   ^

ex.dfy(72,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If value is equal to the root, the result is the same as the original tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t

   |
73 |     match t
   |            ^

ex.dfy(73,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>

   |
74 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(74,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {

   |
75 |       if value < v {
   |                     ^

ex.dfy(75,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);

   |
76 |         InsertPreservesIsBST(left, value, min, v);
   |                                                   ^

ex.dfy(76,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesIsBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {

   |
77 |       } else if value > v {
   |                            ^

ex.dfy(77,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);

   |
78 |         InsertPreservesIsBST(right, value, v, max);
   |                                                    ^

ex.dfy(78,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesIsBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      }

   |
79 |       }
   |        ^

ex.dfy(79,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      }
  }

   |
80 |   }
   |    ^

ex.dfy(80,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&
    value >= min &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
  case Empty => false
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Empty, the result is a new node with the value.
  if t == Empty {
    assert Contains(Node(Empty, value, Empty), value);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Base case: if t is Empty, the result is a new node with the value, which is a BST.
  if t == Empty {
    assert IsBST(Node(Empty, value, Empty), min, max);
  } else {
    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.
    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.
    // If value is equal to the root, the result is the same as the original tree.
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesIsBST(left, value, min, v);
      } else if value > v {
        InsertPreservesIsBST(right, value, v, max);
      }
  }
}

ex.dfy(68,11): Error: assertion might not hold
   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value >= min &&
   |     ^^^^^^^^^^^^

ex.dfy(68,11): Error: assertion might not hold
   |
68 |     assert IsBST(Node(Empty, value, Empty), min, max);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value <= max &&
   |     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  requires IsBST(t, min, max)\n']
['  ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Base case: if t is Empty, the result is a new node with the value.\n']
['  if t == Empty {\n']
['    assert IsBST(Node(Empty, value, Empty), min, max);\n']
['  } else {\n']
['    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.\n']
['    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.\n']
['    // If value is equal to the root, the result is the same as the original tree.\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesIsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertPreservesIsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Base case: if t is Empty, the result is a new node with the value.\n']
['  if t == Empty {\n']
['    assert IsBST(Node(Empty, value, Empty), min, max);\n']
['  } else {\n']
['    // Recursive case: if value is less than the root, the result is a new node with the value inserted into the left subtree.\n']
['    // If value is greater than the root, the result is a new node with the value inserted into the right subtree.\n']
['    // If value is equal to the root, the result is the same as the original tree.\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesIsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertPreservesIsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 55
number of gen nodes: 28 (including leaves: 3)
number of back nodes: 27 (including leaves: 25)

expansion count: 33 (including failed: 6)

cache stats {'hit': 56, 'miss': 115}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379]

Trial calls: [152, 169, 171]


Time Statistics:

  Min: 371.00 sec, Max: 379.00 sec, Average: 374.67 sec, Standard Deviation: 3.30 sec

Call Statistics:

  Min: 152 calls, Max: 171 calls, Average: 164.00 calls, Standard Deviation: 8.52 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379]

Trial calls: [152, 169, 171]


Time Statistics:

  Min: 371.00 sec, Max: 379.00 sec, Average: 374.67 sec, Standard Deviation: 3.30 sec

Call Statistics:

  Min: 152 calls, Max: 171 calls, Average: 164.00 calls, Standard Deviation: 8.52 calls

Trial  4
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil

SCORE
1.0
['  | Nil\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true

   |
10 |   case Nil => true
   |                   ^

ex.dfy(10,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&

   |
12 |     value >= lower &&
   |                      ^

ex.dfy(12,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&

   |
13 |     value < upper &&
   |                     ^

ex.dfy(13,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&

   |
14 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(14,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
15 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(15,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST

SCORE
1.0
['// (3) Insert element into BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t

   |
20 |   reads t
   |         ^

ex.dfy(20,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{

   |
21 | {
   |  ^

ex.dfy(21,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)

   |
22 |   if t == Nil then Node(Nil, value, Nil)
   |                                         ^

ex.dfy(22,40): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil then Node(Nil, value, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)
  else

   |
23 |   else
   |       ^

ex.dfy(23,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)
  else
    match t

   |
24 |     match t
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)
  else
    match t
    case Node(left, t_value, right) =>

   |
25 |     case Node(left, t_value, right) =>
   |                                       ^

ex.dfy(25,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, t_value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)

   |
26 |       if value < t_value then Node(Insert(left, value), t_value, right)
   |                                                                        ^

ex.dfy(26,71): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < t_value then Node(Insert(left, value), t_value, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))

   |
27 |       else if value > t_value then Node(left, t_value, Insert(right, value))
   |                                                                             ^

ex.dfy(27,76): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > t_value then Node(left, t_value, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t

   |
28 |       else t
   |             ^

ex.dfy(28,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Nil then Node(Nil, value, Nil)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

   |
20 |   reads t
   |         ^

ex.dfy(20,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then

   |
21 |   if t == Nil then
   |                   ^

ex.dfy(21,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)

   |
22 |     Node(Nil, value, Nil)
   |                          ^

ex.dfy(22,25): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Nil, value, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else

   |
23 |   else
   |       ^

ex.dfy(23,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t

   |
24 |     match t
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>

   |
25 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(25,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then

   |
26 |       if value < v then
   |                        ^

ex.dfy(26,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)

   |
27 |         Node(Insert(left, value), v, right)
   |                                            ^

ex.dfy(27,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else

   |
28 |       else
   |           ^

ex.dfy(28,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))

   |
29 |         Node(left, v, Insert(right, value))
   |                                            ^

ex.dfy(29,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element

SCORE
1.0
['// (4) Check if tree contains element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false

   |
36 |   case Nil => false
   |                    ^

ex.dfy(36,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then

   |
38 |     if value == v then
   |                       ^

ex.dfy(38,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if value == v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true

   |
39 |       true
   |           ^

ex.dfy(39,10): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then

   |
40 |     else if value < v then
   |                           ^

ex.dfy(40,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)

   |
41 |       Contains(left, value)
   |                            ^

ex.dfy(41,27): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else

   |
42 |     else
   |         ^

ex.dfy(42,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)

   |
43 |       Contains(right, value)
   |                             ^

ex.dfy(43,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element

SCORE
1.0
['// (5) Lemma about insertion maintaining element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)

SCORE
1.0
['lemma InsertMaintainsElement(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true

SCORE
1.0
['  ensures Contains(Insert(t, value), value) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{

   |
49 | {
   |  ^

ex.dfy(49,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Proof by induction on the structure of t

   |
50 |   // Proof by induction on the structure of t
   |                                              ^

ex.dfy(50,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Proof by induction on the structure of t
  if t == Nil then

   |
51 |   if t == Nil then
   |               ^

ex.dfy(51,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Proof by induction on the structure of t
  if t == Nil then
  {

   |
51 |   if t == Nil then
   |               ^

ex.dfy(51,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Proof by induction on the structure of t
  if t == Nil then
  {
    assert Contains(Insert(t, value), value) == true;

   |
51 |   if t == Nil then
   |               ^

ex.dfy(51,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert Contains(Insert(t, value), value) == true;\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Base case

   |
50 |   // Base case
   |               ^

ex.dfy(50,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Base case
  if t == Nil then

   |
51 |   if t == Nil then
   |               ^

ex.dfy(51,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Base case
  if t == Nil then
  {

   |
51 |   if t == Nil then
   |               ^

ex.dfy(51,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value) == true
{
  // Base case
  if t == Nil then
  {
    assert value == Insert(t, value).value;

   |
51 |   if t == Nil then
   |               ^

ex.dfy(51,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert value == Insert(t, value).value;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
50 | {
   |  ^

ex.dfy(50,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t

   |
51 |   // Proof by induction on the structure of t
   |                                              ^

ex.dfy(51,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil

   |
52 |   // Base case: t is Nil
   |                         ^

ex.dfy(52,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Nil\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {

   |
53 |   if t == Nil {
   |                ^

ex.dfy(53,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {

   |
54 |   } else {
   |           ^

ex.dfy(54,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node

   |
55 |     // Inductive step: t is Node
   |                                 ^

ex.dfy(55,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive step: t is Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t

   |
56 |     match t
   |            ^

ex.dfy(56,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>

   |
57 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(57,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {

   |
58 |       if value < v {
   |                     ^

ex.dfy(58,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {

   |
59 |       } else {
   |               ^

ex.dfy(59,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);

   |
60 |         InsertMaintainsElement(right, value);
   |                                              ^

ex.dfy(60,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsElement(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }

   |
61 |       }
   |        ^

ex.dfy(61,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }

   |
62 |   }
   |    ^

ex.dfy(62,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST

SCORE
1.0
['// (6) Lemma about insertion preserving BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{

   |
69 | {
   |  ^

ex.dfy(69,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t

   |
70 |   // Proof by induction on the structure of t
   |                                              ^

ex.dfy(70,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil

   |
71 |   // Base case: t is Nil
   |                         ^

ex.dfy(71,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Nil\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {

   |
72 |   if t == Nil {
   |                ^

ex.dfy(72,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {

   |
73 |   } else {
   |           ^

ex.dfy(73,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node

   |
74 |     // Inductive step: t is Node
   |                                 ^

ex.dfy(74,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive step: t is Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t

   |
75 |     match t
   |            ^

ex.dfy(75,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>

   |
76 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(76,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {

   |
77 |       if value < v {
   |                     ^

ex.dfy(77,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, lower, v);

   |
78 |         InsertPreservesBST(left, value, lower, v);
   |                                                   ^

ex.dfy(78,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(left, value, lower, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, lower, v);
      } else {

   |
79 |       } else {
   |               ^

ex.dfy(79,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, lower, v);
      } else {
        InsertPreservesBST(right, value, v, upper);

   |
80 |         InsertPreservesBST(right, value, v, upper);
   |                                                    ^

ex.dfy(80,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(right, value, v, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, lower, v);
      } else {
        InsertPreservesBST(right, value, v, upper);
      }

   |
81 |       }
   |        ^

ex.dfy(81,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, lower, v);
      } else {
        InsertPreservesBST(right, value, v, upper);
      }
  }

   |
82 |   }
   |    ^

ex.dfy(82,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= lower &&
    value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then
    Node(Nil, value, Nil)
  else
    match t
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else
        Node(left, v, Insert(right, value))
}

// (4) Check if tree contains element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, v, right) =>
    if value == v then
      true
    else if value < v then
      Contains(left, value)
    else
      Contains(right, value)
}

// (5) Lemma about insertion maintaining element
lemma InsertMaintainsElement(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
      } else {
        InsertMaintainsElement(right, value);
      }
  }
}

// (6) Lemma about insertion preserving BST
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by induction on the structure of t
  // Base case: t is Nil
  if t == Nil {
  } else {
    // Inductive step: t is Node
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, lower, v);
      } else {
        InsertPreservesBST(right, value, v, upper);
      }
  }
}

ex.dfy(72,14): Error: a postcondition could not be proved on this return path
   |
72 |   if t == Nil {
   |               ^

ex.dfy(68,8): Related location: this is the postcondition that could not be proved
   |
68 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower &&
   |     ^^^^^^^^^^^^^^

ex.dfy(72,14): Error: a postcondition could not be proved on this return path
   |
72 |   if t == Nil {
   |               ^

ex.dfy(68,8): Related location: this is the postcondition that could not be proved
   |
68 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value < upper &&
   |     ^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t\n']
['  // Base case: t is Nil\n']
['  if t == Nil {\n']
['  } else {\n']
['    // Inductive step: t is Node\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, lower, v);\n']
['      } else {\n']
['        InsertPreservesBST(right, value, v, upper);\n']
['      }\n']
['  }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 69
number of gen nodes: 35 (including leaves: 6)
number of back nodes: 34 (including leaves: 29)

expansion count: 48 (including failed: 14)

cache stats {'hit': 158, 'miss': 103}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372]

Trial calls: [152, 169, 171, 261]


Time Statistics:

  Min: 371.00 sec, Max: 379.00 sec, Average: 374.00 sec, Standard Deviation: 3.08 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.25 calls, Standard Deviation: 42.65 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372]

Trial calls: [152, 169, 171, 261]


Time Statistics:

  Min: 371.00 sec, Max: 379.00 sec, Average: 374.00 sec, Standard Deviation: 3.08 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.25 calls, Standard Deviation: 42.65 calls

Trial  5
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

SCORE
1.0
['datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
['// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t

  |
7 |     match t
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>

  |
8 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(8,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&

  |
9 |         IsBST(left, lower, value) &&
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&

   |
10 |         value <= upper &&
   |                          ^

ex.dfy(10,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&

   |
11 |         value >= lower &&
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)

   |
12 |         IsBST(right, value, upper)
   |                                   ^

ex.dfy(12,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true

   |
13 |     case Leaf => true
   |                      ^

ex.dfy(13,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST

SCORE
1.0
['// (3) Function for inserting an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)

   |
19 |     if t == Leaf then Node(Leaf, value, Leaf)
   |                                              ^

ex.dfy(19,45): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Leaf then Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else

   |
20 |     else
   |         ^

ex.dfy(20,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t

   |
21 |         match t
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>

   |
22 |         case Node(left, v, right) =>
   |                                     ^

ex.dfy(22,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)

   |
23 |             if value < v then Node(Insert(left, value), v, right)
   |                                                                  ^

ex.dfy(23,65): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))

   |
24 |             else if value > v then Node(left, v, Insert(right, value))
   |                                                                       ^

ex.dfy(24,70): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t

   |
25 |             else t
   |                   ^

ex.dfy(25,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element

SCORE
1.0
['// (4) Predicate for checking if a tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{

   |
30 | {
   |  ^

ex.dfy(30,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t

   |
31 |     match t
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>

   |
32 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(32,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value < v ? Contains(left, value) :

   |
33 |         (value < v ? Contains(left, value) :
   |                    ^

ex.dfy(33,19): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['        (value < v ? Contains(left, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value < v ? Contains(left, value) :
         value > v ? Contains(right, value) :

   |
33 |         (value < v ? Contains(left, value) :
   |                    ^

ex.dfy(33,19): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['         value > v ? Contains(right, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value < v ? Contains(left, value) :
         value > v ? Contains(right, value) :
         true)

   |
33 |         (value < v ? Contains(left, value) :
   |                    ^

ex.dfy(33,19): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['         true)\n']
['{\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['        (value < v ? Contains(left, value) :\n']
['         value > v ? Contains(right, value) :\n']
['         true)\n']
['predicate Contains(t: Tree, value: nat)\n']
['{\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)

   |
33 |         (value == v) || Contains(left, value) || Contains(right, value)
   |                                                                        ^

ex.dfy(33,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        (value == v) || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false

   |
34 |     case Leaf => false
   |                       ^

ex.dfy(34,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)

SCORE
1.0
["lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)
{

   |
39 | {
   |  ^

ex.dfy(39,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)
{
    Ensures Contains(t', value)

   |
40 |     Ensures Contains(t', value)
   |     ^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
   |
40 |     Ensures Contains(t', value)
   |                                ^

ex.dfy(40,31): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
["    Ensures Contains(t', value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)
{
    Ensures Contains(t', value)
    // Proof is by structural induction on t

   |
40 |     Ensures Contains(t', value)
   |     ^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
   |
41 |     // Proof is by structural induction on t
   |                                             ^

ex.dfy(41,44): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    // Proof is by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)
{
    Ensures Contains(t', value)
    // Proof is by structural induction on t
}

   |
40 |     Ensures Contains(t', value)
   |     ^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
   |
40 |     Ensures Contains(t', value)
   |             ^^^^^^^^

ex.dfy(40,12): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
["    Ensures Contains(t', value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)
{
    Ensures Contains(t', value)
    t' == Insert(t, value)

   |
40 |     Ensures Contains(t', value)
   |     ^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
   |
40 |     Ensures Contains(t', value)
   |             ^^^^^^^^

ex.dfy(40,12): Error: missing semicolon at end of statement
   |
41 |     t' == Insert(t, value)
   |        ^

ex.dfy(41,7): Error: invalid UpdateStmt
3 parse errors detected in ex.dfy

SCORE
None
["    t' == Insert(t, value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat, t': Tree)
{
    Ensures Contains(t', value)
    t' == Insert(t, value)
}

   |
40 |     Ensures Contains(t', value)
   |     ^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
   |
40 |     Ensures Contains(t', value)
   |             ^^^^^^^^

ex.dfy(40,12): Error: missing semicolon at end of statement
   |
41 |     t' == Insert(t, value)
   |        ^

ex.dfy(41,7): Error: invalid UpdateStmt
3 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on the tree

   |
42 |     // Proof by structural recursion on the tree
   |                                                 ^

ex.dfy(42,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by structural recursion on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on the tree
    match t

   |
43 |     match t
   |            ^

ex.dfy(43,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on the tree
    match t
    case Node(left, v, right) =>

   |
44 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(44,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on the tree
    match t
    case Node(left, v, right) =>
        if value < v then

   |
45 |         if value < v then
   |                      ^

ex.dfy(45,21): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on the tree
    match t
    case Node(left, v, right) =>
        if value < v then
            InsertEnsuresContains(left, value)

   |
45 |         if value < v then
   |                      ^

ex.dfy(45,21): Error: lbrace expected
   |
46 |             InsertEnsuresContains(left, value)
   |                                               ^

ex.dfy(46,46): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['            InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on the tree
    match t
    case Node(left, v, right) =>
        if value < v then
            InsertEnsuresContains(left, value)
        else if value > v then

   |
45 |         if value < v then
   |                      ^

ex.dfy(45,21): Error: lbrace expected
   |
47 |         else if value > v then
   |         ^

ex.dfy(47,8): Error: invalid UpdateStmt
   |
47 |         else if value > v then
   |                           ^

ex.dfy(47,26): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        else if value > v then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on t

   |
42 |     // Proof by structural recursion on t
   |                                          ^

ex.dfy(42,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by structural recursion on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on t
    if t == Leaf then

   |
43 |     if t == Leaf then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Leaf then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on t
    if t == Leaf then
        assert Insert(Leaf, value) == Node(Leaf, value, Leaf);

   |
43 |     if t == Leaf then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Insert(Leaf, value) == Node(Leaf, value, Leaf);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural recursion on t
    if t == Leaf then
        assert Insert(Leaf, value) == Node(Leaf, value, Leaf);
    else

   |
43 |     if t == Leaf then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    else\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural induction on t

   |
42 |     // Proof by structural induction on t
   |                                          ^

ex.dfy(42,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural induction on t
    if t == Leaf then

   |
43 |     if t == Leaf then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Leaf then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural induction on t
    if t == Leaf then
        // Base case: Leaf

   |
43 |     if t == Leaf then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Base case: Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // Proof by structural induction on t
    if t == Leaf then
        // Base case: Leaf
        assert Contains(Node(Leaf, value, Leaf), value);

   |
43 |     if t == Leaf then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        assert Contains(Node(Leaf, value, Leaf), value);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t

   |
42 |     // proof by structural induction on t
   |                                          ^

ex.dfy(42,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf

   |
43 |     // base case: t is Leaf
   |                            ^

ex.dfy(43,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // base case: t is Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf

   |
44 |     if t == Leaf
   |                 ^

ex.dfy(44,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {

   |
45 |     {
   |      ^

ex.dfy(45,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds

   |
46 |         // IsBST(Leaf, value, value) trivially holds
   |                                                     ^

ex.dfy(46,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // IsBST(Leaf, value, value) trivially holds\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);

   |
47 |         assert IsBST(Leaf, value, value);
   |                                          ^

ex.dfy(47,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Leaf, value, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);

   |
48 |         assert Contains(Node(Leaf, value, Leaf), value);
   |                                                         ^

ex.dfy(48,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Node(Leaf, value, Leaf), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }

   |
49 |     }
   |      ^

ex.dfy(49,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node

   |
50 |     // inductive step: t is Node
   |                                 ^

ex.dfy(50,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // inductive step: t is Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else

   |
51 |     else
   |         ^

ex.dfy(51,8): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {

   |
52 |     {
   |      ^

ex.dfy(52,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;

   |
53 |         var left := t.left;
   |                            ^

ex.dfy(53,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var left := t.left;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;

   |
54 |         var v := t.value;
   |                          ^

ex.dfy(54,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var v := t.value;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;

   |
55 |         var right := t.right;
   |                              ^

ex.dfy(55,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var right := t.right;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)

   |
56 |         // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
   |                                                                                  ^

ex.dfy(56,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);

   |
57 |         assert IsBST(left, ?lower, v);
   |                                       ^

ex.dfy(57,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(left, ?lower, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);

   |
58 |         assert IsBST(right, v, ?upper);
   |                                        ^

ex.dfy(58,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(right, v, ?upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)

   |
59 |         // induction hypothesis: Contains(left, value) and Contains(right, value)
   |                                                                                  ^

ex.dfy(59,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // induction hypothesis: Contains(left, value) and Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);

   |
60 |         assert Contains(left, value);
   |                                      ^

ex.dfy(60,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

   |
61 |         assert Contains(right, value);
   |                                       ^

ex.dfy(61,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);


   |
61 |         assert Contains(right, value);
   |                                       ^

ex.dfy(61,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

        // proof for Insert(t, value)

   |
63 |         // proof for Insert(t, value)
   |                                      ^

ex.dfy(63,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // proof for Insert(t, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

        // proof for Insert(t, value)
        // case value < v

   |
64 |         // case value < v
   |                          ^

ex.dfy(64,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // case value < v\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

        // proof for Insert(t, value)
        // case value < v
        if value < v

   |
65 |         if value < v
   |                     ^

ex.dfy(65,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

        // proof for Insert(t, value)
        // case value < v
        if value < v
        {

   |
66 |         {
   |          ^

ex.dfy(66,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

        // proof for Insert(t, value)
        // case value < v
        if value < v
        {
            var t1 := Insert(left, value);

   |
67 |             var t1 := Insert(left, value);
   |                                           ^

ex.dfy(67,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var t1 := Insert(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

        // proof for Insert(t, value)
        // case value < v
        if value < v
        {
            var t1 := Insert(left, value);
            // induction hypothesis: Contains(t1, value)

   |
68 |             // induction hypothesis: Contains(t1, value)
   |                                                         ^

ex.dfy(68,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            // induction hypothesis: Contains(t1, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    // base case: t is Leaf
    if t == Leaf
    {
        // IsBST(Leaf, value, value) trivially holds
        assert IsBST(Leaf, value, value);
        assert Contains(Node(Leaf, value, Leaf), value);
    }
    // inductive step: t is Node
    else
    {
        var left := t.left;
        var v := t.value;
        var right := t.right;
        // induction hypothesis: IsBST(left, lower, v) and IsBST(right, v, upper)
        assert IsBST(left, ?lower, v);
        assert IsBST(right, v, ?upper);
        // induction hypothesis: Contains(left, value) and Contains(right, value)
        assert Contains(left, value);
        assert Contains(right, value);

        // proof for Insert(t, value)
        // case value < v
        if value < v
        {
            var t1 := Insert(left, value);
            // induction hypothesis: Contains(t1, value)
            assert Contains(t1, value);

   |
69 |             assert Contains(t1, value);
   |                                        ^

ex.dfy(69,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert Contains(t1, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{

   |
39 | {
   |  ^

ex.dfy(39,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
    Contains(Insert(t, value), value)

   |
40 |     Contains(Insert(t, value), value)
   |                                      ^

ex.dfy(40,37): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
    Contains(Insert(t, value), value)
}

   |
40 |     Contains(Insert(t, value), value)
   |     ^^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
    Contains(Insert(t, value), value)
}


   |
40 |     Contains(Insert(t, value), value)
   |     ^^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
    Contains(Insert(t, value), value)
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

   |
40 |     Contains(Insert(t, value), value)
   |     ^^^^^^^^

ex.dfy(40,4): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContainment(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t

   |
42 |     // proof by structural induction on t
   |                                          ^

ex.dfy(42,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t

   |
43 |     match t
   |            ^

ex.dfy(43,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);

   |
44 |     case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
   |                                                                  ^

ex.dfy(44,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>

   |
45 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(45,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);

   |
46 |         InsertEnsuresContainment(left, value);
   |                                               ^

ex.dfy(46,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContainment(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);

   |
47 |         InsertEnsuresContainment(right, value);
   |                                                ^

ex.dfy(47,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContainment(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);

   |
48 |         assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
   |                                                                                    ^

ex.dfy(48,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{

   |
55 | {
   |  ^

ex.dfy(55,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t

   |
56 |     // proof by structural induction on t
   |                                          ^

ex.dfy(56,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t

   |
57 |     match t
   |            ^

ex.dfy(57,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);

   |
58 |     case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
   |                                                                      ^

ex.dfy(58,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>

   |
59 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(59,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {

   |
60 |         if value < v {
   |                       ^

ex.dfy(60,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);

   |
61 |             InsertPreservesBST(left, value, lower, v);
   |                                                       ^

ex.dfy(61,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            InsertPreservesBST(left, value, lower, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);

   |
62 |             assert IsBST(Node(Insert(left, value), v, right), lower, upper);
   |                                                                             ^

ex.dfy(62,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert IsBST(Node(Insert(left, value), v, right), lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        } else if value > v {

   |
63 |         } else if value > v {
   |                              ^

ex.dfy(63,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        } else if value > v {
            InsertPreservesBST(right, value, v, upper);

   |
64 |             InsertPreservesBST(right, value, v, upper);
   |                                                        ^

ex.dfy(64,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            InsertPreservesBST(right, value, v, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        } else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);

   |
65 |             assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
   |                                                                             ^

ex.dfy(65,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        } else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        } else {

   |
66 |         } else {
   |                 ^

ex.dfy(66,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        } else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        } else {
            assert IsBST(t, lower, upper);

   |
67 |             assert IsBST(t, lower, upper);
   |                                           ^

ex.dfy(67,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert IsBST(t, lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        } else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        } else {
            assert IsBST(t, lower, upper);
        }

   |
68 |         }
   |          ^

ex.dfy(68,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        } else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        } else {
            assert IsBST(t, lower, upper);
        }
}

ex.dfy(58,24): Error: assertion might not hold
   |
58 |     case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value <= upper &&
   |         ^^^^^^^^^^^^^^

ex.dfy(58,24): Error: assertion might not hold
   |
58 |     case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,8): Related location
   |
11 |         value >= lower &&
   |         ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['    // proof by structural induction on t\n']
['    match t\n']
['    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        InsertPreservesBST(left, value, lower, v);

   |
60 |         InsertPreservesBST(left, value, lower, v);
   |                                                   ^

ex.dfy(60,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(left, value, lower, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        InsertPreservesBST(left, value, lower, v);
        InsertPreservesBST(right, value, v, upper);

   |
61 |         InsertPreservesBST(right, value, v, upper);
   |                                                    ^

ex.dfy(61,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(right, value, v, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        InsertPreservesBST(left, value, lower, v);
        InsertPreservesBST(right, value, v, upper);
        assert IsBST(Node(Insert(left, value), v, Insert(right, value)), lower, upper);

   |
62 |         assert IsBST(Node(Insert(left, value), v, Insert(right, value)), lower, upper);
   |                                                                                        ^

ex.dfy(62,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Node(Insert(left, value), v, Insert(right, value)), lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        InsertPreservesBST(left, value, lower, v);
        InsertPreservesBST(right, value, v, upper);
        assert IsBST(Node(Insert(left, value), v, Insert(right, value)), lower, upper);
}

ex.dfy(58,24): Error: assertion might not hold
   |
58 |     case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value <= upper &&
   |         ^^^^^^^^^^^^^^

ex.dfy(58,24): Error: assertion might not hold
   |
58 |     case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,8): Related location
   |
11 |         value >= lower &&
   |         ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['    // proof by structural induction on t\n']
['    match t\n']
['    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);\n']
['    case Node(left, v, right) =>\n']
['        if value < v {\n']
['            InsertPreservesBST(left, value, lower, v);\n']
['            assert IsBST(Node(Insert(left, value), v, right), lower, upper);\n']
['        } else if value > v {\n']
['            InsertPreservesBST(right, value, v, upper);\n']
['            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);\n']
['        } else {\n']
['            assert IsBST(t, lower, upper);\n']
['        }\n']
['}\n']
['{\n']
['    // proof by structural induction on t\n']
['    match t\n']
['    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);\n']
['    case Node(left, v, right) =>\n']
['        if value < v {\n']
['            InsertPreservesBST(left, value, lower, v);\n']
['            assert IsBST(Node(Insert(left, value), v, right), lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }

   |
63 |         }
   |          ^

ex.dfy(63,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }
        else if value > v {

   |
64 |         else if value > v {
   |                            ^

ex.dfy(64,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }
        else if value > v {
            InsertPreservesBST(right, value, v, upper);

   |
65 |             InsertPreservesBST(right, value, v, upper);
   |                                                        ^

ex.dfy(65,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            InsertPreservesBST(right, value, v, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }
        else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);

   |
66 |             assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
   |                                                                             ^

ex.dfy(66,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }
        else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        }

   |
67 |         }
   |          ^

ex.dfy(67,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }
        else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        }
        else assert IsBST(t, lower, upper);

   |
68 |         else assert IsBST(t, lower, upper);
   |              ^

ex.dfy(68,13): Error: invalid IfStmt
   |
68 |         else assert IsBST(t, lower, upper);
   |                                            ^

ex.dfy(68,43): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        else assert IsBST(t, lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }
        else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        }
        else assert IsBST(t, lower, upper);
}

   |
68 |         else assert IsBST(t, lower, upper);
   |              ^

ex.dfy(68,13): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
    case Leaf => true
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
    if t == Leaf then Node(Leaf, value, Leaf)
    else
        match t
        case Node(left, v, right) =>
            if value < v then Node(Insert(left, value), v, right)
            else if value > v then Node(left, v, Insert(right, value))
            else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
    match t
    case Node(left, v, right) =>
        (value == v) || Contains(left, value) || Contains(right, value)
    case Leaf => false
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContainment(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
    // proof by structural induction on t
    match t
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value);
    case Node(left, v, right) =>
        InsertEnsuresContainment(left, value);
        InsertEnsuresContainment(right, value);
        assert Contains(Node(Insert(left, value), v, Insert(right, value)), value);
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
    // proof by structural induction on t
    match t
    case Leaf => assert IsBST(Node(Leaf, value, Leaf), lower, upper);
    case Node(left, v, right) =>
        if value < v {
            InsertPreservesBST(left, value, lower, v);
            assert IsBST(Node(Insert(left, value), v, right), lower, upper);
        }
        else if value > v {
            InsertPreservesBST(right, value, v, upper);
            assert IsBST(Node(left, v, Insert(right, value)), lower, upper);
        }
        else assert IsBST(t, lower, upper);
}
``` import 'package:flutter/material.dart';

   |
68 |         else assert IsBST(t, lower, upper);
   |              ^

ex.dfy(68,13): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
["``` import 'package:flutter/material.dart';\n"]
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 67
number of gen nodes: 34 (including leaves: 6)
number of back nodes: 33 (including leaves: 28)

expansion count: 46 (including failed: 13)

cache stats {'hit': 46, 'miss': 142}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383]

Trial calls: [152, 169, 171, 261, 188]


Time Statistics:

  Min: 371.00 sec, Max: 383.00 sec, Average: 375.80 sec, Standard Deviation: 4.53 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.20 calls, Standard Deviation: 38.14 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383]

Trial calls: [152, 169, 171, 261, 188]


Time Statistics:

  Min: 371.00 sec, Max: 383.00 sec, Average: 375.80 sec, Standard Deviation: 4.53 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.20 calls, Standard Deviation: 38.14 calls

Trial  6
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Define an ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).

SCORE
1.0
['// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {

  |
7 | function IsBST(tree: Tree, min: nat, max: nat): bool {
  |                                                       ^

ex.dfy(7,54): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function IsBST(tree: Tree, min: nat, max: nat): bool {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {

  |
8 |   match tree {
  |               ^

ex.dfy(8,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true

  |
9 |     case Empty => true
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>

   |
10 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&

   |
11 |       value >= min && value < max &&
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= min && value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&

   |
12 |       IsBST(left, min, value) &&
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)

   |
13 |       IsBST(right, value, max)
   |                               ^

ex.dfy(13,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }

   |
14 |   }
   |    ^

ex.dfy(14,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)

SCORE
1.0
['lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>

   |
18 |   ensures IsBST(tree, min, max) <==>
   |                                     ^

ex.dfy(18,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  ensures IsBST(tree, min, max) <==>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&

   |
19 |           (tree == Empty || (min <= tree.value < max &&
   |                                                        ^

ex.dfy(19,55): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['          (tree == Empty || (min <= tree.value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&

   |
20 |                             IsBST(tree.left, min, tree.value) &&
   |                                                                 ^

ex.dfy(20,64): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['                            IsBST(tree.left, min, tree.value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))

SCORE
1.0
['                            IsBST(tree.right, tree.value, max)))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.

   |
23 |   // Proof is by structural induction on tree.
   |                                               ^

ex.dfy(23,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural induction on tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.

SCORE
1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {

   |
27 | function Insert(tree: Tree, value: nat): Tree {
   |                                                ^

ex.dfy(27,47): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Insert(tree: Tree, value: nat): Tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {

   |
28 |   match tree {
   |               ^

ex.dfy(28,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)

   |
29 |     case Empty => Node(Empty, value, Empty)
   |                                            ^

ex.dfy(29,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, tvalue, right) =>

   |
30 |     case Node(left, tvalue, right) =>
   |                                      ^

ex.dfy(30,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, tvalue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, tvalue, right) =>
      if value < tvalue {

   |
31 |       if value < tvalue {
   |                         ^

ex.dfy(31,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < tvalue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, tvalue, right) =>
      if value < tvalue {
        Node(Insert(left, value), tvalue, right)

   |
31 |       if value < tvalue {
   |                         ^

ex.dfy(31,24): Error: then expected
   |
32 |         Node(Insert(left, value), tvalue, right)
   |                                                 ^

ex.dfy(32,48): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), tvalue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, tvalue, right) =>
      if value < tvalue {
        Node(Insert(left, value), tvalue, right)
      } else if value > tvalue {

   |
31 |       if value < tvalue {
   |                         ^

ex.dfy(31,24): Error: then expected
   |
33 |       } else if value > tvalue {
   |                                ^

ex.dfy(33,31): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > tvalue {\n']
['function Insert(tree: Tree, value: nat): Tree {\n']
['  match tree {\n']
['    case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, treeValue, right) =>

   |
30 |     case Node(left, treeValue, right) =>
   |                                         ^

ex.dfy(30,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, treeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, treeValue, right) =>
      if value < treeValue {

   |
31 |       if value < treeValue {
   |                            ^

ex.dfy(31,27): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < treeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, treeValue, right) =>
      if value < treeValue {
        Node(Insert(left, value), treeValue, right)

   |
31 |       if value < treeValue {
   |                            ^

ex.dfy(31,27): Error: then expected
   |
32 |         Node(Insert(left, value), treeValue, right)
   |                                                    ^

ex.dfy(32,51): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), treeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  match tree {
    case Empty => Node(Empty, value, Empty)
    case Node(left, treeValue, right) =>
      if value < treeValue {
        Node(Insert(left, value), treeValue, right)
      } else if value == treeValue {

   |
31 |       if value < treeValue {
   |                            ^

ex.dfy(31,27): Error: then expected
   |
33 |       } else if value == treeValue {
   |                                    ^

ex.dfy(33,35): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value == treeValue {\n']
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.\n']
['function Insert(tree: Tree, value: nat): Tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then

   |
28 |   if tree == Empty then
   |                        ^

ex.dfy(28,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)

   |
29 |     Node(Empty, value, Empty)
   |                              ^

ex.dfy(29,29): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else

   |
30 |   else
   |       ^

ex.dfy(30,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {

   |
31 |     match tree {
   |                 ^

ex.dfy(31,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>

   |
32 |       case Node(left, tvalue, right) =>
   |                                        ^

ex.dfy(32,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      case Node(left, tvalue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then

   |
33 |         if value < tvalue then
   |                               ^

ex.dfy(33,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        if value < tvalue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)

   |
34 |           Node(Insert(left, value), tvalue, right)
   |                                                   ^

ex.dfy(34,50): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['          Node(Insert(left, value), tvalue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then

   |
35 |         else if value == tvalue then
   |                                     ^

ex.dfy(35,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else if value == tvalue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree

   |
36 |           tree
   |               ^

ex.dfy(36,14): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['          tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else

   |
37 |         else
   |             ^

ex.dfy(37,12): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))

   |
38 |           Node(left, tvalue, Insert(right, value))
   |                                                   ^

ex.dfy(38,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['          Node(left, tvalue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }

   |
39 |     }
   |      ^

ex.dfy(39,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.

SCORE
1.0
['// (4) Write a predicate that checks whether a given tree contains a given element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {

   |
43 | function Contains(tree: Tree, value: nat): bool {
   |                                                  ^

ex.dfy(43,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Contains(tree: Tree, value: nat): bool {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {

   |
44 |   match tree {
   |               ^

ex.dfy(44,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false

   |
45 |     case Empty => false
   |                        ^

ex.dfy(45,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>

   |
46 |     case Node(left, tvalue, right) =>
   |                                      ^

ex.dfy(46,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, tvalue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then

   |
47 |       if value < tvalue then
   |                             ^

ex.dfy(47,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < tvalue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)

   |
48 |         Contains(left, value)
   |                              ^

ex.dfy(48,29): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then

   |
49 |       else if value == tvalue then
   |                                   ^

ex.dfy(49,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if value == tvalue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true

   |
50 |         true
   |             ^

ex.dfy(50,12): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else

   |
51 |       else
   |           ^

ex.dfy(51,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)

   |
52 |         Contains(right, value)
   |                               ^

ex.dfy(52,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }

   |
53 |   }
   |    ^

ex.dfy(53,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertContainment(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
58 | {
   |  ^

ex.dfy(58,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.

   |
59 |   // Proof is by structural induction on tree.
   |                                               ^

ex.dfy(59,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural induction on tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).

SCORE
1.0
['// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesMembership(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{

   |
65 | {
   |  ^

ex.dfy(65,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.

   |
66 |   // Proof is by structural induction on tree.
   |                                               ^

ex.dfy(66,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural induction on tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.

SCORE
1.0
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max) && min <= value < max

SCORE
1.0
['  requires IsBST(tree, min, max) && min <= value < max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max) && min <= value < max
  ensures IsBST(Insert(tree, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max) && min <= value < max
  ensures IsBST(Insert(tree, value), min, max)
{

   |
73 | {
   |  ^

ex.dfy(73,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max) && min <= value < max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof is by structural induction on tree.

   |
74 |   // Proof is by structural induction on tree.
   |                                               ^

ex.dfy(74,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural induction on tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max) && min <= value < max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof is by structural induction on tree.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max) && min <= value < max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof is by structural induction on tree.
}
``` <?php

SCORE
1.0
['``` <?php\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool {
  match tree {
    case Empty => true
    case Node(left, value, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

lemma IsBSTMinMax(tree: Tree, min: nat, max: nat)
  ensures IsBST(tree, min, max) <==>
          (tree == Empty || (min <= tree.value < max &&
                            IsBST(tree.left, min, tree.value) &&
                            IsBST(tree.right, tree.value, max)))
{
  // Proof is by structural induction on tree.
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(tree: Tree, value: nat): Tree {
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree {
      case Node(left, tvalue, right) =>
        if value < tvalue then
          Node(Insert(left, value), tvalue, right)
        else if value == tvalue then
          tree
        else
          Node(left, tvalue, Insert(right, value))
    }
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(tree: Tree, value: nat): bool {
  match tree {
    case Empty => false
    case Node(left, tvalue, right) =>
      if value < tvalue then
        Contains(left, value)
      else if value == tvalue then
        true
      else
        Contains(right, value)
  }
}

lemma InsertContainment(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma InsertPreservesMembership(tree: Tree, value: nat)
  ensures Contains(tree, value) ==> Contains(Insert(tree, value), value)
{
  // Proof is by structural induction on tree.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max) && min <= value < max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof is by structural induction on tree.
}
``` <?php


STATS

number of nodes: 67
number of gen nodes: 34 (including leaves: 2)
number of back nodes: 33 (including leaves: 32)

expansion count: 35 (including failed: 2)

cache stats {'hit': 5, 'miss': 86}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 229]

Trial calls: [152, 169, 171, 261, 188, 91]


Time Statistics:

  Min: 229.00 sec, Max: 383.00 sec, Average: 351.33 sec, Standard Deviation: 54.87 sec

Call Statistics:

  Min: 91 calls, Max: 261 calls, Average: 172.00 calls, Standard Deviation: 50.25 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383]

Trial calls: [152, 169, 171, 261, 188]


Time Statistics:

  Min: 371.00 sec, Max: 383.00 sec, Average: 375.80 sec, Standard Deviation: 4.53 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.20 calls, Standard Deviation: 38.14 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [229]

Trial calls: [91]


Time Statistics:

  Min: 229.00 sec, Max: 229.00 sec, Average: 229.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 91 calls, Max: 91 calls, Average: 91.00 calls, Standard Deviation: 0.00 calls

Trial  7
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t

  |
5 |   match t
  |          ^

ex.dfy(5,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true

  |
6 |   case Leaf => true
  |                    ^

ex.dfy(6,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>

  |
7 |   case Node(l, v, r) =>
  |                        ^

ex.dfy(7,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&

  |
8 |     v >= lo && v <= hi &&
  |                          ^

ex.dfy(8,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= lo && v <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&

  |
9 |     IsBST(l, lo, v) &&
  |                       ^

ex.dfy(9,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l, lo, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)

   |
10 |     IsBST(r, v, hi)
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r, v, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)

   |
15 |   if t == Leaf then Node(Leaf, v, Leaf)
   |                                        ^

ex.dfy(15,39): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf then Node(Leaf, v, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else

   |
16 |   else
   |       ^

ex.dfy(16,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t

   |
17 |     match t
   |            ^

ex.dfy(17,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>

   |
18 |     case Node(l, w, r) =>
   |                          ^

ex.dfy(18,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)

   |
19 |       if v < w then Node(Insert(l, v), w, r)
   |                                             ^

ex.dfy(19,44): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w then Node(Insert(l, v), w, r)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))

   |
20 |       else if v > w then Node(l, w, Insert(r, v))
   |                                                  ^

ex.dfy(20,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if v > w then Node(l, w, Insert(r, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t

   |
21 |       else t
   |             ^

ex.dfy(21,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t

   |
26 |   match t
   |          ^

ex.dfy(26,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false

   |
27 |   case Leaf => false
   |                     ^

ex.dfy(27,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>

   |
28 |   case Node(l, w, r) =>
   |                        ^

ex.dfy(28,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)

   |
29 |     v == w || Contains(l, v) || Contains(r, v)
   |                                               ^

ex.dfy(29,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    v == w || Contains(l, v) || Contains(r, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, v: nat, w: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true

SCORE
1.0
['requires Contains(t, w) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true

SCORE
1.0
['ensures Contains(Insert(t, v), w) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{

   |
35 | {
   |  ^

ex.dfy(35,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case

   |
36 |   // base case
   |               ^

ex.dfy(36,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {

   |
37 |   if t == Leaf {
   |                 ^

ex.dfy(37,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;

   |
38 |     assert w == v;
   |                   ^

ex.dfy(38,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert w == v;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {

   |
39 |   } else {
   |           ^

ex.dfy(39,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case

   |
40 |     // recursive case
   |                      ^

ex.dfy(40,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // recursive case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t

   |
41 |     match t
   |            ^

ex.dfy(41,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>

   |
42 |     case Node(l, x, r) =>
   |                          ^

ex.dfy(42,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, x, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>
      if v < x {

   |
43 |       if v < x {
   |                 ^

ex.dfy(43,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < x {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>
      if v < x {
        InsertPreservesContains(l, v, w);

   |
44 |         InsertPreservesContains(l, v, w);
   |                                          ^

ex.dfy(44,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesContains(l, v, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>
      if v < x {
        InsertPreservesContains(l, v, w);
      } else if v > x {

   |
45 |       } else if v > x {
   |                        ^

ex.dfy(45,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if v > x {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>
      if v < x {
        InsertPreservesContains(l, v, w);
      } else if v > x {
        InsertPreservesContains(r, v, w);

   |
46 |         InsertPreservesContains(r, v, w);
   |                                          ^

ex.dfy(46,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesContains(r, v, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>
      if v < x {
        InsertPreservesContains(l, v, w);
      } else if v > x {
        InsertPreservesContains(r, v, w);
      }

   |
47 |       }
   |        ^

ex.dfy(47,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>
      if v < x {
        InsertPreservesContains(l, v, w);
      } else if v > x {
        InsertPreservesContains(r, v, w);
      }
  }

   |
48 |   }
   |    ^

ex.dfy(48,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // base case
  if t == Leaf {
    assert w == v;
  } else {
    // recursive case
    match t
    case Node(l, x, r) =>
      if v < x {
        InsertPreservesContains(l, v, w);
      } else if v > x {
        InsertPreservesContains(r, v, w);
      }
  }
}

ex.dfy(44,8): Error: a precondition for this call could not be proved
   |
44 |         InsertPreservesContains(l, v, w);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,9): Related location: this is the precondition that could not be proved
   |
33 | requires Contains(t, w) == true
   |          ^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(46,8): Error: a precondition for this call could not be proved
   |
46 |         InsertPreservesContains(r, v, w);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,9): Related location: this is the precondition that could not be proved
   |
33 | requires Contains(t, w) == true
   |          ^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t

   |
36 |   // proof by structural induction on t
   |                                        ^

ex.dfy(36,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  if t == Leaf then

   |
37 |   if t == Leaf then
   |                ^

ex.dfy(37,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  if t == Leaf then
    assert Contains(Node(Leaf, v, Leaf), w) == (v == w);

   |
37 |   if t == Leaf then
   |                ^

ex.dfy(37,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Leaf, v, Leaf), w) == (v == w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  if t == Leaf then
    assert Contains(Node(Leaf, v, Leaf), w) == (v == w);
  else

   |
37 |   if t == Leaf then
   |                ^

ex.dfy(37,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  else\n']
['ensures Contains(Insert(t, v), w) == true\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t

   |
36 |   // prove by structural induction on t
   |                                        ^

ex.dfy(36,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // prove by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true

SCORE
1.0
['requires IsBST(t, lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true

SCORE
1.0
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{

   |
42 | {
   |  ^

ex.dfy(42,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{
  // prove by structural induction on t

   |
43 |   // prove by structural induction on t
   |                                        ^

ex.dfy(43,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // prove by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{
  // prove by structural induction on t
}

ex.dfy(42,0): Error: a postcondition could not be proved on this return path
   |
42 | {
   | ^

ex.dfy(41,8): Related location: this is the postcondition that could not be proved
   |
41 | ensures IsBST(Insert(t, v), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['requires IsBST(t, lo, hi) == true\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsBST(t: Tree, v: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, v: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true

SCORE
1.0
['requires IsBST(t, lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true

SCORE
1.0
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{

   |
42 | {
   |  ^

ex.dfy(42,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{
  // prove by structural induction on t

   |
43 |   // prove by structural induction on t
   |                                        ^

ex.dfy(43,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // prove by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // prove by structural induction on t
}

lemma InsertMaintainsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{
  // prove by structural induction on t
}

ex.dfy(42,0): Error: a postcondition could not be proved on this return path
   |
42 | {
   | ^

ex.dfy(41,8): Related location: this is the postcondition that could not be proved
   |
41 | ensures IsBST(Insert(t, v), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here

   |
36 |   // proof here
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof here\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true

SCORE
1.0
['requires IsBST(t, lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true

SCORE
1.0
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{

   |
42 | {
   |  ^

ex.dfy(42,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{
  // proof here

   |
43 |   // proof here
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof here\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof here
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi) == true
ensures IsBST(Insert(t, v), lo, hi) == true
{
  // proof here
}

ex.dfy(42,0): Error: a postcondition could not be proved on this return path
   |
42 | {
   | ^

ex.dfy(41,8): Related location: this is the postcondition that could not be proved
   |
41 | ensures IsBST(Insert(t, v), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // proof here\n']
['}\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // proof here\n']
['}\n']
['{\n']
['  // proof here\n']
['}\n']
['requires IsBST(t, lo, hi) == true\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // proof here\n']
['}\n']
['{\n']
['  // proof here\n']
['}\n']
['{\n']
['  // proof here\n']
['}\n']
['\n']
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)\n']
['requires IsBST(t, lo, hi) == true\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['requires IsBST(t, lo, hi) == true\n']
['ensures IsBST(Insert(t, v), lo, hi) == true\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // prove by structural induction on t\n']
['}\n']
['{\n']
['  // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf

   |
37 |   // base case: t is Leaf
   |                          ^

ex.dfy(37,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case: t is Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {

   |
38 |   if t == Leaf {
   |                 ^

ex.dfy(38,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove

   |
39 |     // nothing to prove
   |                        ^

ex.dfy(39,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // nothing to prove\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {

   |
40 |   } else {
   |           ^

ex.dfy(40,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)

   |
41 |     // inductive case: t is Node(l, w, r)
   |                                          ^

ex.dfy(41,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // inductive case: t is Node(l, w, r)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);

   |
42 |     assert t == Node(_, w, _);
   |                               ^

ex.dfy(42,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert t == Node(_, w, _);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w

   |
43 |     // case split: v < w, v == w, v > w
   |                                        ^

ex.dfy(43,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // case split: v < w, v == w, v > w\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {

   |
44 |     if v < w {
   |               ^

ex.dfy(44,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true

   |
45 |       // induction hypothesis: Contains(l, w) == true
   |                                                      ^

ex.dfy(45,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // induction hypothesis: Contains(l, w) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true

   |
46 |       // induction step: Contains(Insert(l, v), w) == true
   |                                                           ^

ex.dfy(46,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // induction step: Contains(Insert(l, v), w) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;

   |
47 |       assert Contains(l, w) == true;
   |                                     ^

ex.dfy(47,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(l, w) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;

   |
48 |       assert Contains(Insert(l, v), w) == true;
   |                                                ^

ex.dfy(48,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(Insert(l, v), w) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {

   |
49 |     } else if v == w {
   |                       ^

ex.dfy(49,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v == w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove

   |
50 |       // nothing to prove
   |                          ^

ex.dfy(50,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // nothing to prove\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w

   |
51 |     } else { // v > w
   |                      ^

ex.dfy(51,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else { // v > w\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w
      // induction hypothesis: Contains(r, w) == true

   |
52 |       // induction hypothesis: Contains(r, w) == true
   |                                                      ^

ex.dfy(52,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // induction hypothesis: Contains(r, w) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w
      // induction hypothesis: Contains(r, w) == true
      // induction step: Contains(Insert(r, v), w) == true

   |
53 |       // induction step: Contains(Insert(r, v), w) == true
   |                                                           ^

ex.dfy(53,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // induction step: Contains(Insert(r, v), w) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w
      // induction hypothesis: Contains(r, w) == true
      // induction step: Contains(Insert(r, v), w) == true
      assert Contains(r, w) == true;

   |
54 |       assert Contains(r, w) == true;
   |                                     ^

ex.dfy(54,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(r, w) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w
      // induction hypothesis: Contains(r, w) == true
      // induction step: Contains(Insert(r, v), w) == true
      assert Contains(r, w) == true;
      assert Contains(Insert(r, v), w) == true;

   |
55 |       assert Contains(Insert(r, v), w) == true;
   |                                                ^

ex.dfy(55,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(Insert(r, v), w) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w
      // induction hypothesis: Contains(r, w) == true
      // induction step: Contains(Insert(r, v), w) == true
      assert Contains(r, w) == true;
      assert Contains(Insert(r, v), w) == true;
    }

   |
56 |     }
   |      ^

ex.dfy(56,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w
      // induction hypothesis: Contains(r, w) == true
      // induction step: Contains(Insert(r, v), w) == true
      assert Contains(r, w) == true;
      assert Contains(Insert(r, v), w) == true;
    }
  }

   |
57 |   }
   |    ^

ex.dfy(57,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
requires Contains(t, w) == true
ensures Contains(Insert(t, v), w) == true
{
  // proof by structural induction on t
  // base case: t is Leaf
  if t == Leaf {
    // nothing to prove
  } else {
    // inductive case: t is Node(l, w, r)
    assert t == Node(_, w, _);
    // case split: v < w, v == w, v > w
    if v < w {
      // induction hypothesis: Contains(l, w) == true
      // induction step: Contains(Insert(l, v), w) == true
      assert Contains(l, w) == true;
      assert Contains(Insert(l, v), w) == true;
    } else if v == w {
      // nothing to prove
    } else { // v > w
      // induction hypothesis: Contains(r, w) == true
      // induction step: Contains(Insert(r, v), w) == true
      assert Contains(r, w) == true;
      assert Contains(Insert(r, v), w) == true;
    }
  }
}

   |
42 |     assert t == Node(_, w, _);
   |                      ^

ex.dfy(42,21): Error: unresolved identifier: _
   |
42 |     assert t == Node(_, w, _);
   |                            ^

ex.dfy(42,27): Error: unresolved identifier: _
   |
47 |       assert Contains(l, w) == true;
   |                       ^

ex.dfy(47,22): Error: unresolved identifier: l
   |
48 |       assert Contains(Insert(l, v), w) == true;
   |                              ^

ex.dfy(48,29): Error: unresolved identifier: l
   |
54 |       assert Contains(r, w) == true;
   |                       ^

ex.dfy(54,22): Error: unresolved identifier: r
   |
55 |       assert Contains(Insert(r, v), w) == true;
   |                              ^

ex.dfy(55,29): Error: unresolved identifier: r
6 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)

SCORE
1.0
['lemma InsertPreservesElement(t: Tree, v: nat, w: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)

SCORE
1.0
['requires Contains(t, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)

SCORE
1.0
['ensures Contains(Insert(t, v), w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{

   |
35 | {
   |  ^

ex.dfy(35,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t

   |
36 |   // proof by structural induction on t
   |                                        ^

ex.dfy(36,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi)

SCORE
1.0
['requires IsBST(t, lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi)
ensures IsBST(Insert(t, v), lo, hi)

SCORE
1.0
['ensures IsBST(Insert(t, v), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi)
ensures IsBST(Insert(t, v), lo, hi)
{

   |
42 | {
   |  ^

ex.dfy(42,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi)
ensures IsBST(Insert(t, v), lo, hi)
{
  // proof by structural induction on t

   |
43 |   // proof by structural induction on t
   |                                        ^

ex.dfy(43,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= lo && v <= hi &&
    IsBST(l, lo, v) &&
    IsBST(r, v, hi)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(l, w, r) =>
      if v < w then Node(Insert(l, v), w, r)
      else if v > w then Node(l, w, Insert(r, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, w)
ensures Contains(Insert(t, v), w)
{
  // proof by structural induction on t
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lo: nat, hi: nat)
requires IsBST(t, lo, hi)
ensures IsBST(Insert(t, v), lo, hi)
{
  // proof by structural induction on t
}

ex.dfy(42,0): Error: a postcondition could not be proved on this return path
   |
42 | {
   | ^

ex.dfy(41,8): Related location: this is the postcondition that could not be proved
   |
41 | ensures IsBST(Insert(t, v), lo, hi)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     v >= lo && v <= hi &&
  |     ^^^^^^^

ex.dfy(42,0): Error: a postcondition could not be proved on this return path
   |
42 | {
   | ^

ex.dfy(41,8): Related location: this is the postcondition that could not be proved
   |
41 | ensures IsBST(Insert(t, v), lo, hi)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,15): Related location
  |
8 |     v >= lo && v <= hi &&
  |                ^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // proof by structural induction on t\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 103
number of gen nodes: 52 (including leaves: 14)
number of back nodes: 51 (including leaves: 38)

expansion count: 82 (including failed: 31)

cache stats {'hit': 93, 'miss': 112}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 229, 360]

Trial calls: [152, 169, 171, 261, 188, 91, 205]


Time Statistics:

  Min: 229.00 sec, Max: 383.00 sec, Average: 352.57 sec, Standard Deviation: 50.89 sec

Call Statistics:

  Min: 91 calls, Max: 261 calls, Average: 176.71 calls, Standard Deviation: 47.93 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383]

Trial calls: [152, 169, 171, 261, 188]


Time Statistics:

  Min: 371.00 sec, Max: 383.00 sec, Average: 375.80 sec, Standard Deviation: 4.53 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.20 calls, Standard Deviation: 38.14 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [229, 360]

Trial calls: [91, 205]


Time Statistics:

  Min: 229.00 sec, Max: 360.00 sec, Average: 294.50 sec, Standard Deviation: 65.50 sec

Call Statistics:

  Min: 91 calls, Max: 205 calls, Average: 148.00 calls, Standard Deviation: 57.00 calls

Trial  8
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
1 | datatype Tree =
  |          ^^^^

ex.dfy(1,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

SCORE
1.0
['  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true

  |
8 |   case Leaf => true
  |                    ^

ex.dfy(8,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&

   |
10 |     v >= min && v <= max &&
   |                            ^

ex.dfy(10,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&

   |
11 |     IsBST(left, min, v) &&
   |                           ^

ex.dfy(11,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)

   |
12 |     IsBST(right, v, max)
   |                         ^

ex.dfy(12,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{

   |
16 | {
   |  ^

ex.dfy(16,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)

   |
17 |   if t == Leaf then Node(Leaf, v, Leaf)
   |                                        ^

ex.dfy(17,39): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf then Node(Leaf, v, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else

   |
18 |   else
   |       ^

ex.dfy(18,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t

   |
19 |     match t
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>

   |
20 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)

   |
21 |       if v < w then Node(Insert(left, v), w, right)
   |                                                    ^

ex.dfy(21,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w then Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))

   |
22 |       else if v > w then Node(left, w, Insert(right, v))
   |                                                         ^

ex.dfy(22,56): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if v > w then Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t

   |
23 |       else t
   |             ^

ex.dfy(23,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t

   |
28 |   match t
   |          ^

ex.dfy(28,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false

   |
29 |   case Leaf => false
   |                     ^

ex.dfy(29,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>

   |
30 |   case Node(left, w, right) =>
   |                               ^

ex.dfy(30,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)

   |
31 |     v == w || Contains(left, v) || Contains(right, v)
   |                                                      ^

ex.dfy(31,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    v == w || Contains(left, v) || Contains(right, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)

SCORE
1.0
['lemma Insert_Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)

SCORE
1.0
['requires IsBST(t, 0, 100)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)

SCORE
1.0
['ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.

   |
38 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(38,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf.

   |
39 |   // Base case: t is Leaf.
   |                           ^

ex.dfy(39,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Leaf.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf.
  // If t is Node, recursively call the lemma on left and right.

   |
40 |   // If t is Node, recursively call the lemma on left and right.
   |                                                                 ^

ex.dfy(40,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // If t is Node, recursively call the lemma on left and right.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf.
  // If t is Node, recursively call the lemma on left and right.
}

ex.dfy(37,0): Error: a postcondition could not be proved on this return path
   |
37 | {
   | ^

ex.dfy(36,8): Related location: this is the postcondition that could not be proved
   |
36 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,4): Related location
   |
31 |     v == w || Contains(left, v) || Contains(right, v)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: if t is Leaf

   |
38 |   // base case: if t is Leaf
   |                             ^

ex.dfy(38,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case: if t is Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: if t is Leaf
  // inductive case: if v < w or v > w

   |
39 |   // inductive case: if v < w or v > w
   |                                       ^

ex.dfy(39,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // inductive case: if v < w or v > w\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: if t is Leaf
  // inductive case: if v < w or v > w
  // case v == w: by definition of Contains

   |
40 |   // case v == w: by definition of Contains
   |                                            ^

ex.dfy(40,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // case v == w: by definition of Contains\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: if t is Leaf
  // inductive case: if v < w or v > w
  // case v == w: by definition of Contains
}

ex.dfy(37,0): Error: a postcondition could not be proved on this return path
   |
37 | {
   | ^

ex.dfy(36,8): Related location: this is the postcondition that could not be proved
   |
36 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,4): Related location
   |
31 |     v == w || Contains(left, v) || Contains(right, v)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['ensures Contains(Insert(t, v), v)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case

   |
38 |   // base case
   |               ^

ex.dfy(38,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {

   |
39 |   if t == Leaf {
   |                 ^

ex.dfy(39,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);

   |
40 |     assert Insert(t, v) == Node(Leaf, v, Leaf);
   |                                                ^

ex.dfy(40,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Insert(t, v) == Node(Leaf, v, Leaf);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;

   |
41 |     assert Contains(Insert(t, v), v) == true;
   |                                              ^

ex.dfy(41,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Insert(t, v), v) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;
  } else {

   |
42 |   } else {
   |           ^

ex.dfy(42,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;
  } else {
    match t

   |
43 |     match t
   |            ^

ex.dfy(43,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;
  } else {
    match t
    case Node(left, w, right) => {

   |
44 |     case Node(left, w, right) => {
   |                                   ^

ex.dfy(44,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) => {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;
  } else {
    match t
    case Node(left, w, right) => {
      if v < w {

   |
45 |       if v < w {
   |                 ^

ex.dfy(45,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;
  } else {
    match t
    case Node(left, w, right) => {
      if v < w {
        lemma Insert_Contains(left, v);

   |
46 |         lemma Insert_Contains(left, v);
   |         ^

ex.dfy(46,8): Error: rbrace expected
   |
46 |         lemma Insert_Contains(left, v);
   |                                        ^

ex.dfy(46,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        lemma Insert_Contains(left, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;
  } else {
    match t
    case Node(left, w, right) => {
      if v < w {
        lemma Insert_Contains(left, v);
      } else if v > w {

   |
46 |         lemma Insert_Contains(left, v);
   |         ^

ex.dfy(46,8): Error: rbrace expected
   |
47 |       } else if v > w {
   |         ^

ex.dfy(47,8): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v) == true;
  } else {
    match t
    case Node(left, w, right) => {
      if v < w {
        lemma Insert_Contains(left, v);
      } else if v > w {
        lemma Insert_Contains(right, v);

   |
46 |         lemma Insert_Contains(left, v);
   |         ^

ex.dfy(46,8): Error: rbrace expected
   |
47 |       } else if v > w {
   |         ^

ex.dfy(47,8): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        lemma Insert_Contains(right, v);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // proof here

   |
38 |   // proof here
   |                ^

ex.dfy(38,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof here\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // proof here
}

ex.dfy(37,0): Error: a postcondition could not be proved on this return path
   |
37 | {
   | ^

ex.dfy(36,8): Related location: this is the postcondition that could not be proved
   |
36 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,4): Related location
   |
31 |     v == w || Contains(left, v) || Contains(right, v)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true

SCORE
1.0
['requires Contains(t, v) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true

SCORE
1.0
['ensures Contains(Insert(t, v), v) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.

   |
38 |   // Proof by induction on the structure of t.
   |                                               ^

ex.dfy(38,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
['lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true

SCORE
1.0
['requires IsBST(t, min, max) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true

SCORE
1.0
['ensures IsBST(Insert(t, v), min, max) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t and checking bounds.

   |
45 |   // Proof by induction on the structure of t and checking bounds.
   |                                                                   ^

ex.dfy(45,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t and checking bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t and checking bounds.
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t.

   |
45 |   // Proof by induction on the structure of t.
   |                                               ^

ex.dfy(45,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t.
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, and by checking the BST property after insertion.

   |
45 |   // Proof by induction on the structure of t, and by checking the BST property after insertion.
   |                                                                                                 ^

ex.dfy(45,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t, and by checking the BST property after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, and by checking the BST property after insertion.
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['requires IsBST(t, min, max) == true\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max) == true\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, with bounds on the BST.

   |
45 |   // Proof by induction on the structure of t, with bounds on the BST.
   |                                                                       ^

ex.dfy(45,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t, with bounds on the BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, with bounds on the BST.
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, using the bounds min and max.

   |
45 |   // Proof by induction on the structure of t, using the bounds min and max.
   |                                                                             ^

ex.dfy(45,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t, using the bounds min and max.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, using the bounds min and max.
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf

   |
38 |   // base case: inserting into a Leaf
   |                                      ^

ex.dfy(38,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case: inserting into a Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {

   |
39 |   if t == Leaf {
   |                 ^

ex.dfy(39,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);

   |
40 |     assert Insert(t, v) == Node(Leaf, v, Leaf);
   |                                                ^

ex.dfy(40,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Insert(t, v) == Node(Leaf, v, Leaf);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v);

   |
41 |     assert Contains(Insert(t, v), v);
   |                                      ^

ex.dfy(41,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Insert(t, v), v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v);
  }

   |
42 |   }
   |    ^

ex.dfy(42,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v);
  }
  else

   |
43 |   else
   |       ^

ex.dfy(43,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v);
  }
  else
    match t

   |
44 |     match t
   |     ^

ex.dfy(44,4): Error: invalid IfStmt
   |
44 |     match t
   |            ^

ex.dfy(44,11): Error: invalid MatchStmt
2 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v);
  }
  else
    match t
    case Node(left, w, right) =>

   |
44 |     match t
   |     ^

ex.dfy(44,4): Error: invalid IfStmt
   |
45 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(45,32): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
  // base case: inserting into a Leaf
  if t == Leaf {
    assert Insert(t, v) == Node(Leaf, v, Leaf);
    assert Contains(Insert(t, v), v);
  }
  else
    match t
    case Node(left, w, right) =>
      if v < w {

   |
44 |     match t
   |     ^

ex.dfy(44,4): Error: invalid IfStmt
   |
46 |       if v < w {
   |                 ^

ex.dfy(46,16): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      if v < w {\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
['lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true

SCORE
1.0
['requires IsBST(t, min, max) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true

SCORE
1.0
['ensures IsBST(Insert(t, v), min, max) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
}

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,8): Related location: this is the postcondition that could not be proved
   |
42 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
}
```

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,8): Related location: this is the postcondition that could not be proved
   |
42 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
}
``` #ifndef _H_MSTK_DEFINES

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,8): Related location: this is the postcondition that could not be proved
   |
42 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` #ifndef _H_MSTK_DEFINES\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
}
``` package com.example.android.sunshine.data;

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,8): Related location: this is the postcondition that could not be proved
   |
42 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` package com.example.android.sunshine.data;\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
}
``` import React from "react";

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,8): Related location: this is the postcondition that could not be proved
   |
42 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` import React from "react";\n']
['requires IsBST(t, min, max) == true\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)

SCORE
1.0
['lemma InsertMaintainsContains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)
requires Contains(t, v)

SCORE
1.0
['requires Contains(t, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)
requires Contains(t, v)
ensures Contains(Insert(t, v'), v)

   |
36 | ensures Contains(Insert(t, v'), v)
   |                            ^^

ex.dfy(36,27): Error: unresolved identifier: v'
1 resolution/type errors detected in ex.dfy

SCORE
None
["ensures Contains(Insert(t, v'), v)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)
requires Contains(t, v)
ensures Contains(Insert(t, v'), v)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)
requires Contains(t, v)
ensures Contains(Insert(t, v'), v)
{
  // ...

   |
38 |   // ...
   |         ^

ex.dfy(38,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)
requires Contains(t, v)
ensures Contains(Insert(t, v'), v)
{
  // ...
}

   |
36 | ensures Contains(Insert(t, v'), v)
   |                            ^^

ex.dfy(36,27): Error: unresolved identifier: v'
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
["ensures Contains(Insert(t, v'), v)\n"]
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)
requires Contains(t, v)
ensures Contains(Insert(t, v'), v)
{
  // Proof omitted

   |
38 |   // Proof omitted
   |                   ^

ex.dfy(38,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof omitted\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma InsertMaintainsContains(t: Tree, v: nat)
requires Contains(t, v)
ensures Contains(Insert(t, v'), v)
{
  // Proof omitted
}

   |
36 | ensures Contains(Insert(t, v'), v)
   |                            ^^

ex.dfy(36,27): Error: unresolved identifier: v'
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
['lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max) == true\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
['ensures IsBST(Insert(t, v), min, max) == true\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, using the fact that v is in [min, max].

   |
45 |   // Proof by induction on the structure of t, using the fact that v is in [min, max].
   |                                                                                       ^

ex.dfy(45,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t, using the fact that v is in [min, max].\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t, using the fact that v is in [min, max].
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(t, v), min, max) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by induction on the structure of t.\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true && min <= v && v <= max

SCORE
1.0
['requires IsBST(t, min, max) == true && min <= v && v <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true && min <= v && v <= max
ensures IsBST(Insert(t, v), min, max) == true

SCORE
1.0
['ensures IsBST(Insert(t, v), min, max) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true && min <= v && v <= max
ensures IsBST(Insert(t, v), min, max) == true
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true && min <= v && v <= max
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t.

   |
45 |   // Proof by induction on the structure of t.
   |                                               ^

ex.dfy(45,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

function Insert(t: Tree, v: nat): Tree
{
  if t == Leaf then Node(Leaf, v, Leaf)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v), w, right)
      else if v > w then Node(left, w, Insert(right, v))
      else t
}

predicate Contains(t: Tree, v: nat)
{
  match t
  case Leaf => false
  case Node(left, w, right) =>
    v == w || Contains(left, v) || Contains(right, v)
}

lemma Insert_Contains(t: Tree, v: nat)
requires Contains(t, v) == true
ensures Contains(Insert(t, v), v) == true
{
  // Proof by induction on the structure of t.
}

lemma Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)
requires IsBST(t, min, max) == true && min <= v && v <= max
ensures IsBST(Insert(t, v), min, max) == true
{
  // Proof by induction on the structure of t.
}

SCORE
1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 97
number of gen nodes: 49 (including leaves: 15)
number of back nodes: 48 (including leaves: 34)

expansion count: 79 (including failed: 31)

cache stats {'hit': 77, 'miss': 113}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 229, 360, 362]

Trial calls: [152, 169, 171, 261, 188, 91, 205, 190]


Time Statistics:

  Min: 229.00 sec, Max: 383.00 sec, Average: 353.75 sec, Standard Deviation: 47.70 sec

Call Statistics:

  Min: 91 calls, Max: 261 calls, Average: 178.38 calls, Standard Deviation: 45.05 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 362]

Trial calls: [152, 169, 171, 261, 188, 190]


Time Statistics:

  Min: 362.00 sec, Max: 383.00 sec, Average: 373.50 sec, Standard Deviation: 6.60 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.50 calls, Standard Deviation: 34.83 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [229, 360]

Trial calls: [91, 205]


Time Statistics:

  Min: 229.00 sec, Max: 360.00 sec, Average: 294.50 sec, Standard Deviation: 65.50 sec

Call Statistics:

  Min: 91 calls, Max: 205 calls, Average: 148.00 calls, Standard Deviation: 57.00 calls

Trial  9
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

SCORE
1.0
['  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
['// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&

   |
12 |     lower <= value && value < upper &&
   |                                       ^

ex.dfy(12,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    lower <= value && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&

   |
13 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(13,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
14 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(14,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST

SCORE
1.0
['// (3) Function for inserting an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
  requires IsBST(tree, 0, nat.MaxInt)

   |
19 |   requires IsBST(tree, 0, nat.MaxInt)
   |                           ^

ex.dfy(19,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  requires IsBST(tree, 0, nat.MaxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
  requires IsBST(tree, 0, nat.MaxInt)
  ensures IsBST(tree, 0, nat.MaxInt)

   |
19 |   requires IsBST(tree, 0, nat.MaxInt)
   |                           ^

ex.dfy(19,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  ensures IsBST(tree, 0, nat.MaxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
  requires IsBST(tree, 0, nat.MaxInt)
  ensures IsBST(tree, 0, nat.MaxInt)
  ensures IsBST(result, 0, nat.MaxInt)

   |
19 |   requires IsBST(tree, 0, nat.MaxInt)
   |                           ^

ex.dfy(19,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
['  ensures IsBST(result, 0, nat.MaxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then

   |
20 |   if tree == Leaf then
   |                       ^

ex.dfy(20,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Leaf then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)

   |
21 |     Node(Leaf, value, Leaf)
   |                            ^

ex.dfy(21,27): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else

   |
22 |   else
   |       ^

ex.dfy(22,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree

   |
23 |     match tree
   |               ^

ex.dfy(23,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>

   |
24 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(24,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then

   |
25 |       if value < nodeValue then
   |                                ^

ex.dfy(25,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)

   |
26 |         Node(Insert(left, value), nodeValue, right)
   |                                                    ^

ex.dfy(26,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then

   |
27 |       else if value > nodeValue then
   |                                     ^

ex.dfy(27,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))

   |
28 |         Node(left, nodeValue, Insert(right, value))
   |                                                    ^

ex.dfy(28,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else

   |
29 |       else
   |           ^

ex.dfy(29,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree

   |
30 |         tree
   |             ^

ex.dfy(30,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element

SCORE
1.0
['// (4) Predicate for checking if a tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['predicate Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{

   |
35 | {
   |  ^

ex.dfy(35,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree

   |
36 |   match tree
   |             ^

ex.dfy(36,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false

   |
37 |   case Leaf => false
   |                     ^

ex.dfy(37,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>

   |
38 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(38,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)

   |
39 |     if value < nodeValue then Contains(left, value)
   |                                                    ^

ex.dfy(39,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)

   |
40 |     else if value > nodeValue then Contains(right, value)
   |                                                          ^

ex.dfy(40,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > nodeValue then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true

   |
41 |     else true
   |              ^

ex.dfy(41,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from

SCORE
1.0
['// (5) Lemma about the insert function that ensures that the tree resulting from\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)

SCORE
1.0
['// inserting an element contains that element (without requiring nor ensuring the BST property)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
['lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)

   |
49 |   // ... (proof omitted; use induction and match)
   |                                                  ^

ex.dfy(49,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ... (proof omitted; use induction and match)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the

SCORE
1.0
['// after insertion. This lemma should take bounds on the BST, and require that the\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.

SCORE
1.0
['// element to be inserted is within those bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(tree, lower, upper) && lower <= value && value < upper

SCORE
1.0
['  requires IsBST(tree, lower, upper) && lower <= value && value < upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(tree, lower, upper) && lower <= value && value < upper
  ensures IsBST(Insert(tree, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(tree, lower, upper) && lower <= value && value < upper
  ensures IsBST(Insert(tree, value), lower, upper)
{

   |
58 | {
   |  ^

ex.dfy(58,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(tree, lower, upper) && lower <= value && value < upper
  ensures IsBST(Insert(tree, value), lower, upper)
{
  // ... (proof omitted; use induction and match)

   |
59 |   // ... (proof omitted; use induction and match)
   |                                                  ^

ex.dfy(59,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ... (proof omitted; use induction and match)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(tree, lower, upper) && lower <= value && value < upper
  ensures IsBST(Insert(tree, value), lower, upper)
{
  // ... (proof omitted; use induction and match)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(tree, lower, upper) && lower <= value && value < upper
  ensures IsBST(Insert(tree, value), lower, upper)
{
  // ... (proof omitted; use induction and match)
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then
    Node(Leaf, value, Leaf)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then Contains(left, value)
    else if value > nodeValue then Contains(right, value)
    else true
}

// (5) Lemma about the insert function that ensures that the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:induction} InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // ... (proof omitted; use induction and match)
}

// (6) Lemma about the insert function that checks the BST property continues to hold
// after insertion. This lemma should take bounds on the BST, and require that the
// element to be inserted is within those bounds.
lemma {:induction} InsertPreservesBST(tree: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(tree, lower, upper) && lower <= value && value < upper
  ensures IsBST(Insert(tree, value), lower, upper)
{
  // ... (proof omitted; use induction and match)
}
```


STATS

number of nodes: 59
number of gen nodes: 30 (including leaves: 1)
number of back nodes: 29 (including leaves: 29)

expansion count: 30 (including failed: 1)

cache stats {'hit': 0, 'miss': 64}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 229, 360, 362, 166]

Trial calls: [152, 169, 171, 261, 188, 91, 205, 190, 64]


Time Statistics:

  Min: 166.00 sec, Max: 383.00 sec, Average: 332.89 sec, Standard Deviation: 74.19 sec

Call Statistics:

  Min: 64 calls, Max: 261 calls, Average: 165.67 calls, Standard Deviation: 55.64 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 362]

Trial calls: [152, 169, 171, 261, 188, 190]


Time Statistics:

  Min: 362.00 sec, Max: 383.00 sec, Average: 373.50 sec, Standard Deviation: 6.60 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 188.50 calls, Standard Deviation: 34.83 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [229, 360, 166]

Trial calls: [91, 205, 64]


Time Statistics:

  Min: 166.00 sec, Max: 360.00 sec, Average: 251.67 sec, Standard Deviation: 80.81 sec

Call Statistics:

  Min: 64 calls, Max: 205 calls, Average: 120.00 calls, Standard Deviation: 61.11 calls

Trial  10
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)

SCORE
1.0
['// (1)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)

SCORE
1.0
['// (2)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>

   |
10 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&

   |
11 |     value > min && value < max &&
   |                                  ^

ex.dfy(11,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value > min && value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&

   |
12 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
13 |     IsBST(right, value, max)
   |                             ^

ex.dfy(13,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true

   |
14 |   case Empty => true
   |                     ^

ex.dfy(14,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)

SCORE
1.0
['// (3)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat, min: nat, max: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t

   |
19 |   reads t
   |         ^

ex.dfy(19,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then

   |
21 |   if IsBST(t, min, max) then
   |                             ^

ex.dfy(21,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if IsBST(t, min, max) then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t

   |
22 |     match t
   |            ^

ex.dfy(22,11): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t
    case Node(left, v, right) =>

   |
23 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(23,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value, min, v), v, right)

   |
24 |       if value < v then Node(Insert(left, value, min, v), v, right)
   |                                                                    ^

ex.dfy(24,67): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then Node(Insert(left, value, min, v), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value, min, v), v, right)
      else if value > v then Node(left, v, Insert(right, value, v, max))

   |
25 |       else if value > v then Node(left, v, Insert(right, value, v, max))
   |                                                                         ^

ex.dfy(25,72): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > v then Node(left, v, Insert(right, value, v, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value, min, v), v, right)
      else if value > v then Node(left, v, Insert(right, value, v, max))
      else t

   |
26 |       else t
   |             ^

ex.dfy(26,12): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value, min, v), v, right)
      else if value > v then Node(left, v, Insert(right, value, v, max))
      else t
    case Empty => Node(Empty, value, Empty)

   |
27 |     case Empty => Node(Empty, value, Empty)
   |                                            ^

ex.dfy(27,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value, min, v), v, right)
      else if value > v then Node(left, v, Insert(right, value, v, max))
      else t
    case Empty => Node(Empty, value, Empty)
  else t

   |
28 |   else t
   |         ^

ex.dfy(28,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
  reads t
{
  if IsBST(t, min, max) then
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value, min, v), v, right)
      else if value > v then Node(left, v, Insert(right, value, v, max))
      else t
    case Empty => Node(Empty, value, Empty)
  else t
}

   |
19 |   reads t
   |         ^

ex.dfy(19,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2

   |
20 |   if value < min + (max - min) / 2
   |                                   ^

ex.dfy(20,34): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value < min + (max - min) / 2\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t

   |
21 |   then match t
   |               ^

ex.dfy(21,14): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  then match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)

   |
22 |        case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
   |                                                                                                    ^

ex.dfy(22,99): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)

   |
23 |        case Empty => Node(Empty, value, Empty)
   |                                               ^

ex.dfy(23,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2

   |
24 |   else if value >= min + (max - min) / 2
   |                                         ^

ex.dfy(24,40): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if value >= min + (max - min) / 2\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t

   |
25 |        then match t
   |                    ^

ex.dfy(25,19): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       then match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))

   |
26 |             case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
   |                                                                                                         ^

ex.dfy(26,104): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)

   |
27 |             case Empty => Node(Empty, value, Empty)
   |                                                    ^

ex.dfy(27,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t

   |
28 |        else t
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['       else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)

SCORE
1.0
['// (4)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{

   |
33 | {
   |  ^

ex.dfy(33,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t

   |
34 |   match t
   |          ^

ex.dfy(34,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) => value == x ? true : (value < x ? Contains(left, value) : Contains(right, value))

   |
35 |   case Node(left, x, right) => value == x ? true : (value < x ? Contains(left, value) : Contains(right, value))
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, x, right) => value == x ? true : (value < x ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) => value == x ? true : (value < x ? Contains(left, value) : Contains(right, value))
  case Empty => false

   |
35 |   case Node(left, x, right) => value == x ? true : (value < x ? Contains(left, value) : Contains(right, value))
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) => value == x ? true : (value < x ? Contains(left, value) : Contains(right, value))
  case Empty => false
}

   |
35 |   case Node(left, x, right) => value == x ? true : (value < x ? Contains(left, value) : Contains(right, value))
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>

   |
35 |   case Node(left, x, right) =>
   |                               ^

ex.dfy(35,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, x, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value == x ? true

   |
36 |     value == x ? true
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == x ? true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value == x ? true
             : (value < x ? Contains(left, value)

   |
36 |     value == x ? true
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : (value < x ? Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value == x ? true
             : (value < x ? Contains(left, value)
                          : Contains(right, value))

   |
36 |     value == x ? true
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                          : Contains(right, value))\n']
['predicate Contains(t: Tree, value: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, x, right) =>\n']
['    value == x ? true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value == x ? true
             : (value < x ? Contains(left, value) : Contains(right, value))

   |
36 |     value == x ? true
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : (value < x ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value == x ? true
             : (value < x ? Contains(left, value) : Contains(right, value))
  case Empty => false

   |
36 |     value == x ? true
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => false\n']
['{\n']
['  match t\n']
['  case Node(left, x, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value < x ? Contains(left, value) :

   |
36 |     value < x ? Contains(left, value) :
   |               ^

ex.dfy(36,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value < x ? Contains(left, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value < x ? Contains(left, value) :
    value > x ? Contains(right, value) : true

   |
36 |     value < x ? Contains(left, value) :
   |               ^

ex.dfy(36,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value > x ? Contains(right, value) : true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, x, right) =>
    value < x ? Contains(left, value) :
    value > x ? Contains(right, value) : true
  case Empty => false

   |
36 |     value < x ? Contains(left, value) :
   |               ^

ex.dfy(36,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => false\n']
['// (4)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{

   |
33 | {
   |  ^

ex.dfy(33,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t

   |
34 |   match t
   |          ^

ex.dfy(34,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>

   |
35 |   case Node(left, x, right) =>
   |                               ^

ex.dfy(35,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, x, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||

   |
36 |     (x == value) ||
   |                    ^

ex.dfy(36,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (x == value) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||

   |
37 |     (value < x && Contains(left, value, min, x)) ||
   |                                                    ^

ex.dfy(37,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (value < x && Contains(left, value, min, x)) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))

   |
38 |     (value >= x && Contains(right, value, x, max))
   |                                                   ^

ex.dfy(38,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value >= x && Contains(right, value, x, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false

   |
39 |   case Empty => false
   |                      ^

ex.dfy(39,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)

SCORE
1.0
['// (5)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)

SCORE
1.0
['  ensures Contains(Insert(t, value, min, max), value, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.

   |
46 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(46,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  if value < min + (max - min) / 2

   |
47 |   if value < min + (max - min) / 2
   |                                   ^

ex.dfy(47,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value < min + (max - min) / 2\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  if value < min + (max - min) / 2
  then

   |
48 |   then
   |   ^

ex.dfy(48,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  if value < min + (max - min) / 2
  then
    if t == Empty

   |
48 |   then
   |   ^

ex.dfy(48,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  if value < min + (max - min) / 2
  then
    if t == Empty
    then

   |
48 |   then
   |   ^

ex.dfy(48,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case

   |
46 |   // base case
   |               ^

ex.dfy(46,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2

   |
47 |   if value < min + (max - min) / 2
   |                                   ^

ex.dfy(47,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value < min + (max - min) / 2\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2
  then

   |
48 |   then
   |   ^

ex.dfy(48,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2
  then
    if t == Empty

   |
48 |   then
   |   ^

ex.dfy(48,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2
  then
    if t == Empty
    then assert Contains(Node(Empty, value, Empty), value, min, max);

   |
48 |   then
   |   ^

ex.dfy(48,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    then assert Contains(Node(Empty, value, Empty), value, min, max);\n']
['  ensures Contains(Insert(t, value, min, max), value, min, max)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  if value < min + (max - min) / 2

   |
46 |   if value < min + (max - min) / 2
   |                                   ^

ex.dfy(46,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value < min + (max - min) / 2\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  if value < min + (max - min) / 2
  then

   |
47 |   then
   |   ^

ex.dfy(47,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  if value < min + (max - min) / 2
  then
    if t == Empty

   |
47 |   then
   |   ^

ex.dfy(47,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  if value < min + (max - min) / 2
  then
    if t == Empty
    then assert Contains(Node(Empty, value, Empty), value, min, max);

   |
47 |   then
   |   ^

ex.dfy(47,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    then assert Contains(Node(Empty, value, Empty), value, min, max);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // proof here

   |
46 |   // proof here
   |                ^

ex.dfy(46,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof here\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // proof here
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,10): Related location: this is the postcondition that could not be proved
   |
44 |   ensures Contains(Insert(t, value, min, max), value, min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)

SCORE
1.0
['  ensures Contains(Insert(t, value, min, max), value, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // induction on t

   |
46 |   // induction on t
   |                    ^

ex.dfy(46,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // induction on t
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,10): Related location: this is the postcondition that could not be proved
   |
44 |   ensures Contains(Insert(t, value, min, max), value, min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...

   |
46 |   // ...
   |         ^

ex.dfy(46,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,10): Related location: this is the postcondition that could not be proved
   |
44 |   ensures Contains(Insert(t, value, min, max), value, min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...

   |
46 |   // ...
   |         ^

ex.dfy(46,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:auto} InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,10): Related location: this is the postcondition that could not be proved
   |
44 |   ensures Contains(Insert(t, value, min, max), value, min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['// (5)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)

SCORE
1.0
['  ensures Contains(Insert(t, value, min, max), value, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.

   |
46 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(46,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.

   |
47 |   // Base case: t is Empty.
   |                            ^

ex.dfy(47,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty

   |
48 |   if t == Empty
   |                ^

ex.dfy(48,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {

   |
49 |   {
   |    ^

ex.dfy(49,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);

   |
50 |     assert Contains(Insert(t, value, min, max), value, min, max);
   |                                                                  ^

ex.dfy(50,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Insert(t, value, min, max), value, min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }

   |
51 |   }
   |    ^

ex.dfy(51,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.

   |
52 |   // Inductive step: t is Node.
   |                                ^

ex.dfy(52,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: t is Node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else

   |
53 |   else
   |       ^

ex.dfy(53,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {

   |
54 |   {
   |    ^

ex.dfy(54,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t

   |
55 |     match t
   |            ^

ex.dfy(55,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>

   |
56 |     case Node(left, x, right) =>
   |                                 ^

ex.dfy(56,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, x, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.

   |
57 |       // Proof by cases on where value is in relation to x.
   |                                                            ^

ex.dfy(57,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Proof by cases on where value is in relation to x.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x

   |
58 |       if value < x
   |                   ^

ex.dfy(58,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < x\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {

   |
59 |       {
   |        ^

ex.dfy(59,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.

   |
60 |         // Recursively call the lemma on left.
   |                                               ^

ex.dfy(60,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Recursively call the lemma on left.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);

   |
61 |         assert Contains(Insert(left, value, min, x), value, min, x);
   |                                                                     ^

ex.dfy(61,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Insert(left, value, min, x), value, min, x);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }

   |
62 |       }
   |        ^

ex.dfy(62,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x

   |
63 |       else if value >= x
   |                         ^

ex.dfy(63,24): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value >= x\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {

   |
64 |       {
   |        ^

ex.dfy(64,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.

   |
65 |         // Recursively call the lemma on right.
   |                                                ^

ex.dfy(65,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Recursively call the lemma on right.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);

   |
66 |         assert Contains(Insert(right, value, x, max), value, x, max);
   |                                                                      ^

ex.dfy(66,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Insert(right, value, x, max), value, x, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);
      }

   |
67 |       }
   |        ^

ex.dfy(67,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);
      }
      else

   |
68 |       else
   |           ^

ex.dfy(68,10): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);
      }
      else
      {

   |
69 |       {
   |        ^

ex.dfy(69,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);
      }
      else
      {
        // Base case: value == x.

   |
70 |         // Base case: value == x.
   |                                  ^

ex.dfy(70,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Base case: value == x.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);
      }
      else
      {
        // Base case: value == x.
      }

   |
71 |       }
   |        ^

ex.dfy(71,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);
      }
      else
      {
        // Base case: value == x.
      }
  }

   |
72 |   }
   |    ^

ex.dfy(72,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  if t == Empty
  {
    assert Contains(Insert(t, value, min, max), value, min, max);
  }
  // Inductive step: t is Node.
  else
  {
    match t
    case Node(left, x, right) =>
      // Proof by cases on where value is in relation to x.
      if value < x
      {
        // Recursively call the lemma on left.
        assert Contains(Insert(left, value, min, x), value, min, x);
      }
      else if value >= x
      {
        // Recursively call the lemma on right.
        assert Contains(Insert(right, value, x, max), value, x, max);
      }
      else
      {
        // Base case: value == x.
      }
  }
}

ex.dfy(59,6): Error: a postcondition could not be proved on this return path
   |
59 |       {
   |       ^

ex.dfy(44,10): Related location: this is the postcondition that could not be proved
   |
44 |   ensures Contains(Insert(t, value, min, max), value, min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...

   |
46 |   // ...
   |         ^

ex.dfy(46,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,10): Related location: this is the postcondition that could not be proved
   |
44 |   ensures Contains(Insert(t, value, min, max), value, min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['  ensures Contains(Insert(t, value, min, max), value, min, max)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // prove by cases on value < min + (max - min) / 2 and value >= min + (max - min) / 2

   |
46 |   // prove by cases on value < min + (max - min) / 2 and value >= min + (max - min) / 2
   |                                                                                        ^

ex.dfy(46,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // prove by cases on value < min + (max - min) / 2 and value >= min + (max - min) / 2\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // prove by cases on value < min + (max - min) / 2 and value >= min + (max - min) / 2
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,10): Related location: this is the postcondition that could not be proved
   |
44 |   ensures Contains(Insert(t, value, min, max), value, min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // ...\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)

SCORE
1.0
['ensures Contains(Insert(t, value, min, max), value, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...

   |
47 |   // ...
   |         ^

ex.dfy(47,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // ...
}

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures Contains(Insert(t, value, min, max), value, min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (x == value) ||
   |     ^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case

   |
47 |   // base case
   |               ^

ex.dfy(47,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2

   |
48 |   if value < min + (max - min) / 2
   |                                   ^

ex.dfy(48,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value < min + (max - min) / 2\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2
  then

   |
49 |   then
   |   ^

ex.dfy(49,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2
  then
    match t

   |
49 |   then
   |   ^

ex.dfy(49,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures Contains(Insert(t, value, min, max), value, min, max)
{
  // base case
  if value < min + (max - min) / 2
  then
    match t
    case Node(left, x, right) =>

   |
49 |   then
   |   ^

ex.dfy(49,2): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(left, x, right) =>\n']
['\n']
['// (5)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:induction} Insert_Contains(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:induction} Insert_Contains(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:induction} Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)

SCORE
1.0
['  ensures Contains(Insert(t, value, min, max), value, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:induction} Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:induction} Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)

// (6)

SCORE
1.0
['// (6)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:induction} Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)

// (6)
lemma {:induction} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:induction} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3)
function Insert(t: Tree, value: nat, min: nat, max: nat): Tree
{
  if value < min + (max - min) / 2
  then match t
       case Node(left, x, right) => Node(Insert(left, value, min, min + (max - min) / 2), x, right)
       case Empty => Node(Empty, value, Empty)
  else if value >= min + (max - min) / 2
       then match t
            case Node(left, x, right) => Node(left, x, Insert(right, value, min + (max - min) / 2, max))
            case Empty => Node(Empty, value, Empty)
       else t
}

// (4)
predicate Contains(t: Tree, value: nat, min: nat, max: nat)
{
  match t
  case Node(left, x, right) =>
    (x == value) ||
    (value < x && Contains(left, value, min, x)) ||
    (value >= x && Contains(right, value, x, max))
  case Empty => false
}

// (5)
lemma {:induction} Insert_Contains(t: Tree, value: nat, min: nat, max: nat)
  ensures Contains(Insert(t, value, min, max), value, min, max)

// (6)
lemma {:induction} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value && value < max

SCORE
1.0
['  requires min <= value && value < max\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 77
number of gen nodes: 39 (including leaves: 9)
number of back nodes: 38 (including leaves: 30)

expansion count: 56 (including failed: 18)

cache stats {'hit': 27, 'miss': 147}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 229, 360, 362, 166, 361]

Trial calls: [152, 169, 171, 261, 188, 91, 205, 190, 64, 174]


Time Statistics:

  Min: 166.00 sec, Max: 383.00 sec, Average: 335.70 sec, Standard Deviation: 70.89 sec

Call Statistics:

  Min: 64 calls, Max: 261 calls, Average: 166.50 calls, Standard Deviation: 52.85 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [374, 371, 379, 372, 383, 362, 361]

Trial calls: [152, 169, 171, 261, 188, 190, 174]


Time Statistics:

  Min: 361.00 sec, Max: 383.00 sec, Average: 371.71 sec, Standard Deviation: 7.52 sec

Call Statistics:

  Min: 152 calls, Max: 261 calls, Average: 186.43 calls, Standard Deviation: 32.64 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [229, 360, 166]

Trial calls: [91, 205, 64]


Time Statistics:

  Min: 166.00 sec, Max: 360.00 sec, Average: 251.67 sec, Standard Deviation: 80.81 sec

Call Statistics:

  Min: 64 calls, Max: 205 calls, Average: 120.00 calls, Standard Deviation: 61.11 calls

To complete all experiments, 56 minutes and 47 seconds elapsed.


