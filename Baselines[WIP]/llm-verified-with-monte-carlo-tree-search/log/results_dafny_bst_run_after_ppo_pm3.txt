

========
Experiment configuration: python run.py --base_model_name ./my_dpo_model --problem_name problem_bst 


[2024-01-07 04:34:52,000] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t

  |
5 | predicate IsBST(t: Tree, min: nat, max: nat) reads t
  |                                                    ^

ex.dfy(5,51): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['predicate IsBST(t: Tree, min: nat, max: nat) reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
10 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(10,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
12 |     IsBST(right, value, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

  |
5 | predicate IsBST(t: Tree, min: nat, max: nat) reads t
  |                                                    ^

ex.dfy(5,51): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t

  |
8 |   match t
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true

  |
9 |   case Empty => true
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
10 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
11 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(11,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
12 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
13 |     IsBST(right, value, max)
   |                             ^

ex.dfy(13,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
7 |   reads min, max
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
7 |   reads min, max
  |              ^^^

ex.dfy(7,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
None
['  reads min, max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max


  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
7 |   reads min, max
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
7 |   reads min, max
  |              ^^^

ex.dfy(7,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max

function Insert(t: Tree, x: nat): Tree

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
7 |   reads min, max
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
7 |   reads min, max
  |              ^^^

ex.dfy(7,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['function Insert(t: Tree, x: nat): Tree\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t

  |
8 |   match t
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t
  case Empty => true

  |
9 |   case Empty => true
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>

   |
10 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(10,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    IsBST(l, lower, v) &&

   |
11 |     IsBST(l, lower, v) &&
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    IsBST(l, lower, v) &&
    v <= upper &&

   |
12 |     v <= upper &&
   |                  ^

ex.dfy(12,17): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    IsBST(l, lower, v) &&
    v <= upper &&
    v >= lower &&

   |
13 |     v >= lower &&
   |                  ^

ex.dfy(13,17): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    IsBST(l, lower, v) &&
    v <= upper &&
    v >= lower &&
    IsBST(r, v, upper)

   |
14 |     IsBST(r, v, upper)
   |                       ^

ex.dfy(14,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    IsBST(l, lower, v) &&
    v <= upper &&
    v >= lower &&
    IsBST(r, v, upper)
}

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
10 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
11 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
12 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(12,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{

   |
16 | {
   |  ^

ex.dfy(16,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t

   |
17 |   match t
   |          ^

ex.dfy(17,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
18 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(18,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>

   |
19 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(19,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then

   |
20 |     if value < v then
   |                      ^

ex.dfy(20,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)

   |
21 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(21,41): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then

   |
22 |     else if value > v then
   |                           ^

ex.dfy(22,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))

   |
23 |       Node(left, v, Insert(right, value))
   |                                          ^

ex.dfy(23,41): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else

   |
24 |     else
   |         ^

ex.dfy(24,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t

   |
25 |       t
   |        ^

ex.dfy(25,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t

   |
30 |   match t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false

   |
31 |   case Empty => false
   |                      ^

ex.dfy(31,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>

   |
32 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(32,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)

   |
33 |     v == value || Contains(left, value) || Contains(right, value)
   |                                                                  ^

ex.dfy(33,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    v == value || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)

SCORE
1.0
['  ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{

   |
38 | {
   |  ^

ex.dfy(38,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.

   |
39 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(39,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t

   |
40 |   match t
   |          ^

ex.dfy(40,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
41 |   case Empty =>
   |                ^

ex.dfy(41,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.

   |
42 |     // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
   |                                                                                      ^

ex.dfy(42,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>

   |
43 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(43,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:

   |
44 |     // Inductive case:
   |                       ^

ex.dfy(44,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {

   |
45 |     if v < value {
   |                   ^

ex.dfy(45,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.

   |
46 |       // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
   |                                                                                                 ^

ex.dfy(46,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.

   |
47 |       // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
   |                                                                          ^

ex.dfy(47,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {

   |
48 |     } else if v > value {
   |                          ^

ex.dfy(48,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.

   |
49 |       // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
   |                                                                                                   ^

ex.dfy(49,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.

   |
50 |       // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
   |                                                                           ^

ex.dfy(50,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {

   |
51 |     } else {
   |             ^

ex.dfy(51,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.

   |
52 |       // In this case, Insert(t, v) = t, by the third case of the match in Insert.
   |                                                                                   ^

ex.dfy(52,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = t, by the third case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.

   |
53 |       // Thus, Contains(t, v) holds.
   |                                     ^

ex.dfy(53,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Thus, Contains(t, v) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }

   |
54 |     }
   |      ^

ex.dfy(54,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{

   |
60 | {
   |  ^

ex.dfy(60,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.

   |
61 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(61,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t

   |
62 |   match t
   |          ^

ex.dfy(62,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
63 |   case Empty =>
   |                ^

ex.dfy(63,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.

   |
64 |     // Base case: IsBST(Empty, lower, upper) holds by definition.
   |                                                                  ^

ex.dfy(64,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: IsBST(Empty, lower, upper) holds by definition.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,

   |
65 |     // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
   |                                                                                                ^

ex.dfy(65,95): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.

   |
66 |     // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
   |                                                                           ^

ex.dfy(66,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>

   |
67 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(67,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:

   |
68 |     // Inductive case:
   |                       ^

ex.dfy(68,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {

   |
69 |     if v < value {
   |                   ^

ex.dfy(69,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.

   |
70 |       // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
   |                                                                                                 ^

ex.dfy(70,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.

   |
71 |       // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
   |                                                                                  ^

ex.dfy(71,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.

   |
72 |       // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
   |                                                                                    ^

ex.dfy(72,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {

   |
73 |     } else if v > value {
   |                          ^

ex.dfy(73,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.

   |
74 |       // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
   |                                                                                                   ^

ex.dfy(74,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.

   |
75 |       // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
   |                                                                                   ^

ex.dfy(75,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.

   |
76 |       // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
   |                                                                                    ^

ex.dfy(76,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {

   |
77 |     } else {
   |             ^

ex.dfy(77,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.

   |
78 |       // In this case, Insert(t, v) = t, by the third case of the match in Insert.
   |                                                                                   ^

ex.dfy(78,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = t, by the third case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds.

   |
79 |       // Thus, IsBST(t, lower, upper) holds.
   |                                             ^

ex.dfy(79,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Thus, IsBST(t, lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds.
    }

   |
80 |     }
   |      ^

ex.dfy(80,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // Insert(Empty, v) = Node(Empty, v, Empty), which is a BST with root v and empty subtrees,
    // and IsBST(Node(Empty, v, Empty), lower, upper) holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds.
    }
}

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  match t\n']
['  case Empty =>\n']
['    // Base case: IsBST(Empty, lower, upper) holds by definition.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.

   |
65 |     // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
   |                                                                                                        ^

ex.dfy(65,103): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>

   |
66 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(66,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:

   |
67 |     // Inductive case:
   |                       ^

ex.dfy(67,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {

   |
68 |     if v < value {
   |                   ^

ex.dfy(68,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).

   |
69 |       // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
   |                                                                                                       ^

ex.dfy(69,102): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).

   |
70 |       // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
   |                                                                                            ^

ex.dfy(70,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.

   |
71 |       // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
   |                                                                                    ^

ex.dfy(71,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {

   |
72 |     } else if v > value {
   |                          ^

ex.dfy(72,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).

   |
73 |       // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
   |                                                                                                       ^

ex.dfy(73,102): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).

   |
74 |       // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).
   |                                                                                              ^

ex.dfy(74,93): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.

   |
75 |       // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
   |                                                                                    ^

ex.dfy(75,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {

   |
76 |     } else {
   |             ^

ex.dfy(76,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, after Insert, we have IsBST(Node(left, value, right), lower, upper).

   |
77 |       // In this case, after Insert, we have IsBST(Node(left, value, right), lower, upper).
   |                                                                                            ^

ex.dfy(77,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, after Insert, we have IsBST(Node(left, value, right), lower, upper).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, after Insert, we have IsBST(Node(left, value, right), lower, upper).
      // Since v = value and IsBST(t, lower, upper) holds, this also holds.

   |
78 |       // Since v = value and IsBST(t, lower, upper) holds, this also holds.
   |                                                                            ^

ex.dfy(78,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Since v = value and IsBST(t, lower, upper) holds, this also holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, after Insert, we have IsBST(Node(left, value, right), lower, upper).
      // Since v = value and IsBST(t, lower, upper) holds, this also holds.
    }

   |
79 |     }
   |      ^

ex.dfy(79,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) holds by definition.
    // After Insert, we have IsBST(Node(Empty, v, Empty), lower, upper) which also holds by definition.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, after Insert, we have IsBST(Node(Insert(left, v), value, right), lower, upper).
      // By the inductive hypothesis on left, we know IsBST(Insert(left, v), lower, value).
      // Therefore, IsBST(Node(Insert(left, v), value, right), lower, upper) holds.
    } else if v > value {
      // In this case, after Insert, we have IsBST(Node(left, value, Insert(right, v)), lower, upper).
      // By the inductive hypothesis on right, we know IsBST(Insert(right, v), value, upper).
      // Therefore, IsBST(Node(left, value, Insert(right, v)), lower, upper) holds.
    } else {
      // In this case, after Insert, we have IsBST(Node(left, value, right), lower, upper).
      // Since v = value and IsBST(t, lower, upper) holds, this also holds.
    }
}

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  match t\n']
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),

   |
64 |     // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
   |                                                                                                              ^

ex.dfy(64,109): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.

   |
65 |     // which is a BST with lower and upper bounds lower and upper.
   |                                                                   ^

ex.dfy(65,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // which is a BST with lower and upper bounds lower and upper.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>

   |
66 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(66,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:

   |
67 |     // Inductive case:
   |                       ^

ex.dfy(67,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {

   |
68 |     if v < value {
   |                   ^

ex.dfy(68,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.

   |
69 |       // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
   |                                                                                                 ^

ex.dfy(69,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.

   |
70 |       // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
   |                                                                                  ^

ex.dfy(70,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).

   |
71 |       // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
   |                                                                                                             ^

ex.dfy(71,108): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {

   |
72 |     } else if v > value {
   |                          ^

ex.dfy(72,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.

   |
73 |       // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
   |                                                                                                   ^

ex.dfy(73,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.

   |
74 |       // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
   |                                                                                   ^

ex.dfy(74,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).

   |
75 |       // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).
   |                                                                                                             ^

ex.dfy(75,108): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).
    } else {

   |
76 |     } else {
   |             ^

ex.dfy(76,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.

   |
77 |       // In this case, Insert(t, v) = t, by the third case of the match in Insert.
   |                                                                                   ^

ex.dfy(77,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = t, by the third case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds.

   |
78 |       // Thus, IsBST(t, lower, upper) holds.
   |                                             ^

ex.dfy(78,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Thus, IsBST(t, lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds.
    }

   |
79 |     }
   |      ^

ex.dfy(79,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: IsBST(Empty, lower, upper) is vacuously true, and Insert(Empty, v) = Node(Empty, v, Empty),
    // which is a BST with lower and upper bounds lower and upper.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, lower, upper) and value >= lower, it follows that IsBST(Insert(t, v), lower, upper).
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, upper) and value <= upper, it follows that IsBST(Insert(t, v), lower, upper).
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds.
    }
}

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  match t\n']
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.

   |
64 |     // Base case: Since t is empty, the property holds vacuously.
   |                                                                  ^

ex.dfy(64,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: Since t is empty, the property holds vacuously.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>

   |
65 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(65,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:

   |
66 |     // Inductive case:
   |                       ^

ex.dfy(66,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {

   |
67 |     if v < value {
   |                   ^

ex.dfy(67,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.

   |
68 |       // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
   |                                                                                                 ^

ex.dfy(68,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.

   |
69 |       // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
   |                                                                                  ^

ex.dfy(69,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.

   |
70 |       // Thus, IsBST(Insert(t, v), lower, upper) holds.
   |                                                        ^

ex.dfy(70,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Thus, IsBST(Insert(t, v), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {

   |
71 |     } else if v > value {
   |                          ^

ex.dfy(71,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.

   |
72 |       // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
   |                                                                                                   ^

ex.dfy(72,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.

   |
73 |       // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
   |                                                                                   ^

ex.dfy(73,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.

   |
74 |       // Thus, IsBST(Insert(t, v), lower, upper) holds.
   |                                                        ^

ex.dfy(74,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Thus, IsBST(Insert(t, v), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else {

   |
75 |     } else {
   |             ^

ex.dfy(75,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.

   |
76 |       // In this case, Insert(t, v) = t, by the third case of the match in Insert.
   |                                                                                   ^

ex.dfy(76,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = t, by the third case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) and thus IsBST(Insert(t, v), lower, upper) holds.

   |
77 |       // Thus, IsBST(t, lower, upper) and thus IsBST(Insert(t, v), lower, upper) holds.
   |                                                                                        ^

ex.dfy(77,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Thus, IsBST(t, lower, upper) and thus IsBST(Insert(t, v), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) and thus IsBST(Insert(t, v), lower, upper) holds.
    }

   |
78 |     }
   |      ^

ex.dfy(78,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(left, v), lower, value) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, IsBST(Insert(right, v), value, upper) holds.
      // Thus, IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) and thus IsBST(Insert(t, v), lower, upper) holds.
    }
}

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(63,2): Error: a postcondition could not be proved on this return path
   |
63 |   case Empty =>
   |   ^^^^

ex.dfy(59,10): Related location: this is the postcondition that could not be proved
   |
59 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper

SCORE
1.0
['  requires IsBST(t, lower, upper) && lower <= v && v <= upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{

   |
60 | {
   |  ^

ex.dfy(60,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.

   |
61 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(61,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t

   |
62 |   match t
   |          ^

ex.dfy(62,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
63 |   case Empty =>
   |                ^

ex.dfy(63,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.

   |
64 |     // Base case: Since t is empty, the property holds vacuously.
   |                                                                  ^

ex.dfy(64,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: Since t is empty, the property holds vacuously.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>

   |
65 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(65,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.

   |
66 |     // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
   |                                                                                     ^

ex.dfy(66,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {

   |
67 |     if v < value {
   |                   ^

ex.dfy(67,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.

   |
68 |       // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
   |                                                                                                 ^

ex.dfy(68,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),

   |
69 |       // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
   |                                                                                      ^

ex.dfy(69,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.

   |
70 |       // IsBST(Insert(left, v), lower, value) holds.
   |                                                     ^

ex.dfy(70,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // IsBST(Insert(left, v), lower, value) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that

   |
71 |       // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
   |                                                                                     ^

ex.dfy(71,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.

   |
72 |       // IsBST(Insert(t, v), lower, upper) holds.
   |                                                  ^

ex.dfy(72,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // IsBST(Insert(t, v), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {

   |
73 |     } else if v > value {
   |                          ^

ex.dfy(73,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.

   |
74 |       // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
   |                                                                                                   ^

ex.dfy(74,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),

   |
75 |       // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
   |                                                                                      ^

ex.dfy(75,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.

   |
76 |       // IsBST(Insert(right, v), value, upper) holds.
   |                                                      ^

ex.dfy(76,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // IsBST(Insert(right, v), value, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that

   |
77 |       // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
   |                                                                                     ^

ex.dfy(77,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.

   |
78 |       // IsBST(Insert(t, v), lower, upper) holds.
   |                                                  ^

ex.dfy(78,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // IsBST(Insert(t, v), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {

   |
79 |     } else {
   |             ^

ex.dfy(79,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.

   |
80 |       // In this case, Insert(t, v) = t, by the third case of the match in Insert.
   |                                                                                   ^

ex.dfy(80,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, Insert(t, v) = t, by the third case of the match in Insert.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that

   |
81 |       // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that
   |                                                                                  ^

ex.dfy(81,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that
      // IsBST(Insert(t, v), lower, upper) holds.

   |
82 |       // IsBST(Insert(t, v), lower, upper) holds.
   |                                                  ^

ex.dfy(82,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // IsBST(Insert(t, v), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    }

   |
83 |     }
   |      ^

ex.dfy(83,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    }
}
``` package org.apache.ignite.internal.processors.query.h2.sql;

SCORE
1.0
['``` package org.apache.ignite.internal.processors.query.h2.sql;\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Insert(Empty, v) = Node(Empty, v, Empty), which clearly contains v.
  case Node(left, value, right) =>
    // Inductive case:
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(left, v), v) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis, Contains(Insert(right, v), v) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, Contains(t, v) holds.
    }
}

lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper) && lower <= v && v <= upper
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    // Base case: Since t is empty, the property holds vacuously.
  case Node(left, value, right) =>
    // Inductive case: We need to show that IsBST(Insert(t, v), lower, upper) holds.
    if v < value {
      // In this case, Insert(t, v) = Insert(left, v), by the first case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= v < value <= upper),
      // IsBST(Insert(left, v), lower, value) holds.
      // Since IsBST(t, value, upper) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else if v > value {
      // In this case, Insert(t, v) = Insert(right, v), by the second case of the match in Insert.
      // By the inductive hypothesis (and the fact that lower <= value < v <= upper),
      // IsBST(Insert(right, v), value, upper) holds.
      // Since IsBST(t, lower, value) (by the inductive hypothesis), it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    } else {
      // In this case, Insert(t, v) = t, by the third case of the match in Insert.
      // Thus, IsBST(t, lower, upper) holds, and since value = v, it follows that
      // IsBST(Insert(t, v), lower, upper) holds.
    }
}
``` package org.apache.ignite.internal.processors.query.h2.sql;


STATS

number of nodes: 53
number of gen nodes: 27 (including leaves: 4)
number of back nodes: 26 (including leaves: 23)

expansion count: 34 (including failed: 8)

cache stats {'hit': 16, 'miss': 190}
9 minutes and 44 seconds elapsed.


