TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)


SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: function (string) returns (int)): int

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: function (string) returns (int)): int
{

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
 
SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}


SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}


SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
 
SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);
      OptimizerPreservesSemantics(e1, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ => 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ => 

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ => 
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ => 
  }

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases for the lemma
  if e == Const(_) || e == Var(_) {
  } else {
    // Recursive case for the lemma
    match e
    case Add(e1, e2) =>
      var o1 := Optimize(e1);
      var o2 := Optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ => 
  }
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else
  // Base case: e is neither a constant, variable, nor addition

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else
  // Base case: e is neither a constant, variable, nor addition
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else
  // Base case: e is neither a constant, variable, nor addition
  {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else
  // Base case: e is neither a constant, variable, nor addition
  {
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else
  // Base case: e is neither a constant, variable, nor addition
  {
  }

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e == Const(0) {
  } else
  // Base case: e is a variable
  if e == Var(0) {
  } else
  // Inductive case: e is an addition
  if e == Add(e1, e2) {
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  } else
  // Base case: e is neither a constant, variable, nor addition
  {
  }
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 
  case Add(e1, e2) =>

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 
  case Add(e1, e2) =>
    assert Optimize(e) == Optimize(Add(Optimize(e1), Optimize(e2)));

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 
  case Add(e1, e2) =>
    assert Optimize(e) == Optimize(Add(Optimize(e1), Optimize(e2)));
    OptimizerPreservesSemantics(e1, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 
  case Add(e1, e2) =>
    assert Optimize(e) == Optimize(Add(Optimize(e1), Optimize(e2)));
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => 
  case Var(_) => 
  case Add(e1, e2) =>
    assert Optimize(e) == Optimize(Add(Optimize(e1), Optimize(e2)));
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e is Const then

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e is Const then
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: e is a constant
  if e is Const then
  {

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
 
SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);
{

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);
{

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);


SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);

    // Recursively invoke the lemma

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);

    // Recursively invoke the lemma
    OptimizerPreservesSemantics(e.e1, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);

    // Recursively invoke the lemma
    OptimizerPreservesSemantics(e.e1, env);
    OptimizerPreservesSemantics(e.e2, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);

    // Recursively invoke the lemma
    OptimizerPreservesSemantics(e.e1, env);
    OptimizerPreservesSemantics(e.e2, env);
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);

    // Recursively invoke the lemma
    OptimizerPreservesSemantics(e.e1, env);
    OptimizerPreservesSemantics(e.e2, env);
  }

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the lemma holds trivially
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, we recursively invoke the lemma on the sub-expressions
  else if e is Add
  {
    // Optimize the sub-expressions
    var o1 := Optimize(e.e1);
    var o2 := Optimize(e.e2);

    // Recursively invoke the lemma
    OptimizerPreservesSemantics(e.e1, env);
    OptimizerPreservesSemantics(e.e2, env);
  }
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{
  Eval(Optimize(e), env) == Eval(e, env)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{
  Eval(Optimize(e), env) == Eval(e, env)
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);


SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

// Proof of the lemma

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

// Proof of the lemma
method OptimizerPreservesSemantics()

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

// Proof of the lemma
{

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

// Proof for the lemma

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

// Proof for the lemma
proof

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);

// Proof for the lemma
{

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the optimizer
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env);
{

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}


SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
 
SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
}

SCORE
0.6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
}
```
SCORE
0.6
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

// Optimizer
function Optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) => 
    var o1 := Optimize(e1);
    var o2 := Optimize(e2);
    if o2 == Const(0) then o1 else
    if o1 == Const(0) then o2 else Add(o1, o2)
  case _ => e
}

// Lemma for the preservation of semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
}
```
